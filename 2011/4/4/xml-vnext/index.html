<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>XML v.next</title>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="/static/css/main.min.css" type="text/css" media="all">
        <!--[if lte IE 8]>
            <link rel="stylesheet" href="/static/css/ie-fixes.css" type="text/css" media="all">
            <script src="/static/js/html5shiv.js"></script>
        <![endif]-->

        <meta http-equiv="last-modified" content="Mon, 04 Apr 2011 12:45:52 GMT">
        <link rel="alternate" type="application/atom+xml" title="All Posts (Atom)" href="/feeds/all.atom">
        <link rel="alternate" type="application/rss+xml" title="All Posts (RSS)" href="/feeds/all.rss">
        <link rel="icon" type="image/jpeg" sizes="287x287" href="/static/img/favicon-287x287.jpg">
        <link rel="icon" type="image/jpeg" sizes="128x128" href="/static/img/favicon-128x128.jpg">
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-2097834-1', 'auto');
            ga('send', 'pageview');
        </script>
    </head>
    <body class="blog post_detail" itemscope itemtype="http://schema.org/BlogPosting">
        <nav id="site-nav">
            <header id="about">
                <h1><a href="/about/">Chris Adams</a></h1>
                <h2>Programmer, cyclist, photographer</h2>
            </header>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/feeds/all.atom" title="Site Feed">Site Feed</a>
                </li>
            </ul>
            <ul class="social-networks">
                <li>
                    <a href="https://github.com/acdha" rel="me">Github</a>
                </li>
                <li>
                    <a href="https://bitbucket.org/acdha" rel="me">Bitbucket</a>
                </li>
                <li>
                    <a href="https://pinboard.in/u:acdha/" rel="me">Pinboard</a>
                </li>
                <li>
                    <a href="https://twitter.com/acdha" rel="me">Twitter</a>
                </li>
                <li>
                    <a href="https://www.flickr.com/photos/acdha" rel="me">Flickr</a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/in/acdha" rel="me">LinkedIn</a>
                </li>
            </ul>
            <div id="site-search"></div>
        </nav>
        <section id="main">
            <article class="post">
                <header>
                    <meta itemprop="dateCreated" content="2011-04-04T08:45:52-04:00">
                    <meta itemprop="dateModified" content="2011-04-04T08:45:52-04:00">
                    <time class="date" itemprop="datePublished" datetime="2011-04-04T12:45:52+00:00">Apr 04</time>
                    <h2 class="" itemprop="title">XML v.next</h2>
                </header>

                <div class="body" itemprop="articleBody"><div class="googlereader description" data-google-id="tag:google.com,2005:reader/item/00a485cf3a89a7dd">
                        <p class="annotation">
                            Interesting discussion
                        </p>
                        <blockquote>
                            <div>
                                <div>
                                    <div>
                                        <p>
                                            If you weren't paying attention when XML was being designed, it may seem odd that it carries so much SGML heritage on its back. Surely, it could have been made even simpler if it didn't have to be compatible with SGML. And it really didn't, did it?
                                        </p>
                                    </div>
                                    <p>
                                        I enjoyed reading <span><span>John</span> <span>Cowan</span></span>’s poster for <a href="http://blog.jclark.com/2010/12/more-on-microxml.html">MicroXML</a> at <a href="http://xmlprague.cz/">XML Prague</a>. As I stood there, thinking about the constraints and eavesdropping on conversations about them<sup><span>[</span><a name="p2.4" href="http://norman.walsh.name/2011/03/28/XMLvNext#ftn.p2.4" id="p2.4">1</a><span>]</span></sup>, an idea began to form.
                                    </p>
                                    <p>
                                        By dinner time the idea was firmly established. If we're thinking of creating an even-simpler-still angle bracket markup language in the spirit of XML, is backwards compatibility with XML <em>really</em> a requirement? Or is XML 1.0 just our SGML?
                                    </p>
                                    <div>
                                        <h2>
                                            Sidebar
                                        </h2>
                                        <div>
                                            <p>
                                                The question of whether XML really had to be compatible with SGML is impossible to answer. What can be said for sure is that <em>at the time</em>, it <em>seemed</em> absolutely necessary. SGML was a large, successful system. XML was an alternative to SGML. If the SGML community didn't/couldn't/wouldn't migrate to XML, it felt like XML would be <a href="http://en.wikipedia.org/wiki/Dead_on_arrival" title="Wikipedia: Dead on arrival">DOA</a>.
                                            </p>
                                        </div>
                                    </div>
                                    <p>
                                        I'm going to go out on a limb and suggest that <em>syntactic</em> compatibility with XML <em>is not</em> a requirement. I believe the real constraint is that it must be possible to process these new documents with existing XML tools. Concretely, it think these new documents must have a data model that is compatible with the <a href="http://en.wikipedia.org/wiki/XPath_2.0%23Data_model" title="Wikipedia: XPath 2.0#Data model">XDM</a>. (I'd be happy to declare that their data model <em>is</em> the XDM and be done with it, but that's probably not necessary.)
                                    </p>
                                    <p>
                                        This is the important bit, so I'll repeat it: I think this new language can be syntactically incompatible, but it <em>must</em> produce a data model that is completely compatible with the XDM. (<em>n.b.</em> this is not reflexive, it's ok if there are some XDMs that <em>can't</em> be represented in the new language.)
                                    </p>
                                    <p>
                                        The overwhelming benefit of this approach is that all the existing validation, transformation, and other XML processing tools will “just work” with these new documents (after they're parsed). It's possible that we can develop simpler technologies for these new documents, but we don't have to start over with the whole stack.
                                    </p>
                                    <p>
                                        This is like the question, “how you process HTML5 with XML tools?” The answer is you stick a new parser on the front and then process the tree. A couple of the ideas I outline below require extensions to the XDM, but not big ones, and I think they're things that are already in sort of a gray area. XSLT and XQuery, for example, can already produce XDMs that no XML parser can produce.
                                    </p>
                                    <p>
                                        If there's even a snowball's chance in hell of successfully deploying a successor to XML that solves substantially the same problems as XML, it had better be <em>damned compelling</em>. It better really be simpler. It better really shake off the complexities that chafe XML's detractors (and even some of its champions).
                                    </p>
                                    <div>
                                        <h2>
                                            Sidebar
                                        </h2>
                                        <div>
                                            <p>
                                                MicroXML, as described by <span><span>James</span></span> and John and others, <em>is not</em> intended as a successor to XML. I think I understand the rationale for that point of view, but I don't think that's how most people are thinking about it. If there's something simpler, and it gets any adoption at all, that's what people will want to use. It will be a de facto successor, even if it isn't explicitly established as one.
                                            </p>
                                        </div>
                                    </div>
                                    <p>
                                        If the cost of simplification is only a new, presumably also simpler, parser at the front end [<em>only!?</em> —ed], I think that <em>might</em> be a cost that could be borne. The alternative, I fear, is going to be a language that's not substantially, obviously, compellingly simpler and consequently one that cannot succeed.
                                    </p>
                                    <p>
                                        Here are some of the ideas rolling around in my head. I doubt they're all good ones, but at least a few of them “feel” pretty good. In case that's just angle bracket overload and sleep deprivation from Prague, I won't assert which ones. They're in an ordered list only for labelling purposes, not because there's anything intrinsic about the order.
                                    </p>
                                    <div>
                                        <ol style="list-style:decimal">
                                            <li>
                                                <p>
                                                    Remove the restriction that a document can have only a single root node.
                                                </p>
                                            </li>
                                            <li>
                                                <p>
                                                    Drop the DOCTYPE. I'm not trying to make something compatible with HTML5, a point I'll come back to below, so I don't see any point in allowing the empty declaration.
                                                </p>
                                            </li>
                                            <li>
                                                <p>
                                                    Discard comments in favor of an <tt>&lt;xml:comment&gt;</tt> element. Discard processing instructions in favor of an <tt>&lt;xml:pi target="name"&gt;</tt> element (or <tt>&lt;xml:processing-instruction&gt;</tt>, if you really prefer). In theory, this extends the data model because these elements could have structure; to avoid that, we say that their value is their string-value irrespective of what they contain. (Authors get benefits anyway, since they'll nest properly.)
                                                </p>
                                                <p>
                                                    Note that these new elements don't have any impact on validation, they are a syntactic device; they become comments and processing instructions in the data model. They lose their “elementness” when parsed, so you can't/don't have to validate them.
                                                </p>
                                                <p>
                                                    I think I'd keep the XML declaration as it is. It's not a PI anyway, despite all appearances to the contrary. And it's useful for character encoding detection.
                                                </p>
                                            </li>
                                            <li>
                                                <p>
                                                    Allow attribute values to be repeated, so that lists can be represented without microparsing<sup><span>[</span><a name="p18.1" href="http://norman.walsh.name/2011/03/28/XMLvNext#ftn.p18.1" id="p18.1">2</a><span>]</span></sup>. Note that this isn't a departure from the XDM either. This element:
                                                </p>
                                                <div>
                                                    <pre>
&lt;phrase condition="secret" condition="expert"&gt;...&lt;/phrase&gt;
</pre>
                                                </div>
                                                <p>
                                                    has a single “<tt>condition</tt>” attribute whose value is a sequence of two strings, <tt>("secret", "expert")</tt>.
                                                </p>
                                            </li>
                                            <li>
                                                <p>
                                                    Support <tt>xml:id</tt> and <tt>xml:base</tt>. It's hugely tempting to allow multiple ID values on a single element, but I'll have to look more closely at how the XDM deals with IDs before I'd be willing to commit to that. (I'm not short-changing <tt>xml:link</tt> [shouldn't you? --ed], but I think it can remain a separate specification.)
                                                </p>
                                            </li>
                                            <li>
                                                <p>
                                                    Perhaps the hardest question: what to do about namespaces? One radical proposal is to do away with them, but I can't support that. I'm prepared to be persuaded by any number of simplification proposals, but I'll start by outlining my own.
                                                </p>
                                                <p>
                                                    I think the biggest problems with namespaces are the fact that they use a silly pseudo-attribute syntax and they nest. You wind up with declarations scattered willy nilly across documents and every element has to carry a potentially different set of in-scope namespaces. You can never really be sure when you're looking at an element that you know what's in scope without scanning all its ancestors.
                                                </p>
                                                <p>
                                                    So let's fix that. Introduce namespaces, globally, only at the top of a document, with element syntax (in the XDM, these declarations appear on (all the) root elements):
                                                </p>
                                                <div>
                                                    <pre>
&lt;xml:ns prefix="dc" uri="http://purl.org/dc/elements/1.1/"/&gt;
&lt;xml:ns prefix="xlink" uri="http://www.w3.org/1999/xlink"/&gt;
&lt;xml:ns prefix="" uri="http://docbook.org/ns/docbook"/&gt;
&lt;book&gt;...&lt;/book&gt;
</pre>
                                                </div>
                                                <p>
                                                    In theory, this complicates some use cases, but I've used namespaces <em>a lot</em> and I've rarely taken advantage of the ability to redeclare prefixes part way through a document and I doubt I've ever been in a situation where I <em>needed</em> to do that.
                                                </p>
                                                <p>
                                                    In some “cut-and-paste” scenarios, it may be necessary to do a little fixup, but I'm not confident that those scenarios arise often enough to justify the cost. Plus the cost doesn't really fix the problem. Grabbing elements in a text editor and pasting them into a new document doesn't magically carry over their in-scope namespaces. And if you've got a tool smart enough to carry them over, can't it be smart enough to fixup the declarations at the top?
                                                </p>
                                                <p>
                                                    (Some folks would like to replace URIs with something more like Java package names. I think that ship has sailed, and I don't really agree anyway. <a href="http://norman.walsh.name/2004/03/03/266NorthPleasant">I like URIs</a>.)
                                                </p>
                                            </li>
                                            <li>
                                                <p>
                                                    Introduce a lexical syntax for expanded names that doesn't require a prefix. We could use what the XPath folks are thinking of for expressions, <tt>"namespace-uri":local-name</tt>. You can use that form for elements and attribute names, literally:
                                                </p>
                                                <div>
                                                    <pre>
&lt;"http://docbook.org/ns/docbook":book&gt;...
</pre>
                                                </div>
                                                <p>
                                                    You must use the same form for the start tag and the end tag. I'd be tempted to go a step further and reuse or introduce a “markup start character” for the purpose, but I'm not sure it's necessary.
                                                </p>
                                            </li>
                                            <li>
                                                <p>
                                                    Introduce some sort of error correction. This is a slippery slope and it's not clear how far down we can go without losing our footing entirely. Allowing users to omit the quote marks around attribute values that don't contain spaces seems easy (and it will make at least one user very happy ☺).
                                                </p>
                                                <p>
                                                    We could also allowing “&amp;” and “&lt;" to be their literal selves if they're not followed by a name character.
                                                </p>
                                                <p>
                                                    We could say that a closing tag closes any open tags necessary to make the tree balanced.
                                                </p>
                                                <p>
                                                    I'm not sure it's possible to go much further. Any error correction algorithm has to be consistent and schema-independent so a lot of HTML-style fixup isn't possible. (The HTML parser knows a lot about the elements it sees, the same isn't true for XML in general; I don't think I'd want to introduce two different flavors of error-correction, depending on whether or not the schema is known.)
                                                </p>
                                            </li>
                                            <li>
                                                <p>
                                                    Allow text content and attribute values to contain any sequence of Unicode characters, including <tt>NUL</tt>. If we feel really uncomfortable with the fact that this makes encoding detection harder, we could say that any document that uses control characters must assert it in the XML declaration and must assert the encoding: “<tt>&lt;?xml encoding="utf-8;binary"?&gt;</tt>”.
                                                </p>
                                                <p>
                                                    This would open the door to the possibility of adding explicit support for text and binary content. We could introduce “<tt>&lt;xml:text&gt;</tt>” and “<tt>&lt;xml:binary&gt;</tt>”. Each have a <tt>content-type</tt> and a <tt>boundary</tt> attribute. The boundary is arbitrary but must occur immediately before the closing tag. The boundary is not part of the content but provides an extensible mechanism for assuring that the boundary can always be found. (And that the string “<tt>&lt;/xml:text&gt;</tt>” can occur inside a text block.)
                                                </p>
                                                <p>
                                                    This has the added advantage of removing the need for “<tt>&lt;![CDATA[</tt>”:
                                                </p>
                                                <div>
                                                    <pre>
&lt;xml:text content-type="text/plain"&gt;&lt;random&gt;In XML 1.0 this might
have been a CDATA section &amp; “]]&gt;” would
not have been allowed.&lt;/xml:text&gt;
</pre>
                                                </div>
                                                <p>
                                                    I didn't need to specify a boundary, but I could have:
                                                </p>
                                                <div>
                                                    <pre>
&lt;xml:text content-type="text/plain" boundary="EOT"&gt;&lt;random&gt;In XML 1.0 this might
have been a CDATA section &amp; “]]&gt;” would
not have been allowed.EOT&lt;/xml:text&gt;
</pre>
                                                </div>
                                            </li>
                                        </ol>
                                    </div>
                                    <p>
                                        Of course, the danger in doing this sort of exercise is that engineers are good at thinking up clever features. Add enough clever features and it won't be simpler, just differently complex.
                                    </p>
                                    <div>
                                        <h2>
                                            What about enties? 
                                        </h2>
                                        <p>
                                            Short of grandfathering in all the MathML entity names, the HTML5 solution, nothing about what I've proposed here attempts to address the problem of declaring names for characters.
                                        </p>
                                        <p>
                                            The reason that DTDs can define entities (and W3C XML Schema and RELAX NG cannot) is that entities require either the ability to leave unexpanded entities in the data model or some way to interact with the parser.
                                        </p>
                                        <p>
                                            Some data models support unexpanded entity declarations (and start/end boundaries), but in practice very few tools do. The XDM doesn't, so I'm not going to try.
                                        </p>
                                        <p>
                                            But what I'm outlining here is a language that needs a new parser, so we have more freedom. We could introduce an <tt>&lt;xml:macro&gt;</tt> facility, for example, but I'm not sure it's a good idea.
                                        </p>
                                    </div>
                                    <div>
                                        <h2>
                                            What about HTML5? 
                                        </h2>
                                        <p>
                                            One of the motivations for simplifying XML is to make it more compatible with HTML5. I understand the appeal, but I'm not sure there's any long term benefit to be gained.
                                        </p>
                                        <div>
                                            <ol style="list-style:decimal">
                                                <li>
                                                    <p>
                                                        No parser for a simplfied XML will ever be able to successfully parse the vast majority of strings that an HTML5 parser will accept. So if you need to read HTML5, you need an HTML5 parser.
                                                    </p>
                                                </li>
                                                <li>
                                                    <p>
                                                        If you want to write XML documents that can be parsed by an HTML5 parser, you already can: there's even <a href="http://www.w3.org/TR/html-polyglot/">a spec for that</a>. If you're willing to live within the constraints of XML, you're already 90% of the way there. I can easily imagine a syntax checker/converter that reads “ordinary” XML and, where possible, makes it “polyglot”. Or an editing mode that restricts you to polyglot constructs.
                                                    </p>
                                                </li>
                                                <li>
                                                    <p>
                                                        Having a simplified XML won't help address the problems caused by the fact that the HTML5 parser infers structure that no XML parser will. Just making it simplified doesn't make it the same as HTML.
                                                    </p>
                                                </li>
                                                <li>
                                                    <p>
                                                        Having a simplified XML won't help address the problem of embedding islands of XML in HTML. You just can't do that without wrapping the XML in a <tt>&lt;script&gt;</tt> at which point it's all just CDATA anyway.
                                                    </p>
                                                </li>
                                            </ol>
                                        </div>
                                        <p>
                                            XML is <em>just fine</em> as it is. Yes, it has some warts and odd complexities but so do most things. Does anyone actually believe that the intersection of HTML, CSS, and JavaScript in the landscape of modern web browsers is <em>intrinsicly less complex</em> than XML?
                                        </p>
                                        <p>
                                            No, I'm slowly coming [being dragged, kicking and screaming, would be more accurate —ed] to the realization that users get pissed off about some kinds of complexity and not others. When XML was developed, making it easy to parse was a definite goal. It was something the <a href="http://www.xml.com/pub/a/w3j/s3.perl.html">desperate Perl hacker</a> should be able to cook up quickly. That was a visceral reaction to SGML which was <em>so</em> difficult to parse, it's possible that only a small handful of fully conformant SGML parsers <em>ever existed</em>.
                                        </p>
                                        <p>
                                            I have on more than one occasion muttered something unkind when someone [<span><span>Tim</span></span> —ed] harped on about quoted attribute values. Surely, I'd moan, <em>that's</em> not the important bit! But maybe it is. Or at least maybe it's way more annoying to more people than I imagine. I'll grant that it's the kind of complexity that seems arbitrary rather than necessary which may be what's annoying about it.
                                        </p>
                                    </div>
                                    <div>
                                        <h2>
                                            Conclusions 
                                        </h2>
                                        <p>
                                            HTML has taught users that markup doesn't have to be perfect. You can be a little bit sloppy and it comes out ok. The XML community can process those documents by putting an HTML5 parser on the front end. We can produce those documents by writing our XML according to the polyglot pattern.
                                        </p>
                                        <p>
                                            Some (perhaps many) HTML users will never need more than HTML offers. But some will want to author or process documents with a richer structure than HTML, or to use XML tools like XSLT and XProc that require XML authoring. We can reduce the barrier to entry for these folks by making an XML-datamodel-compatible but slightly-more-forgiving language.
                                        </p>
                                        <p>
                                            The goal would be that such documents are parsed and then treated just exactly like they'd come from their XML equivalents. So the overall cost to the XML ecosystem is quite small.
                                        </p>
                                        <p>
                                            Is this worth doing? Does the proverbial snowball have a chance?
                                        </p>
                                        <p>
                                            I dunno, but I think I feel better about this direction than I do about trying to create a simple-but-syntactically-compatible subset of XML. It's interesting to compare my current thinking with <a href="http://norman.walsh.name/2008/02/20/xml20">three years ago</a>.
                                        </p>
                                    </div>
                                    <div>
                                        <hr width="100" align="left">
                                        <div>
                                            <p>
                                                <sup><span>[</span><a href="http://norman.walsh.name/2011/03/28/XMLvNext#p2.4" name="ftn.p2.4" id="ftn.p2.4">1</a><span>]</span></sup>The common sentiment, predictably, was that it was just right except for <em>this one thing</em> where the one thing differed for almost everyone.
                                            </p>
                                        </div>
                                        <div>
                                            <p>
                                                <sup><span>[</span><a href="http://norman.walsh.name/2011/03/28/XMLvNext#p18.1" name="ftn.p18.1" id="ftn.p18.1">2</a><span>]</span></sup>Credit to <span><span>Jason</span> <span>Hunter</span></span> for this one.
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </blockquote>
                    </div>
                    <p class="bookmark-source">
                        Source: <a href="http://norman.walsh.name/2011/03/28/XMLvNext">http://norman.walsh.name/2011/03/28/XMLvNext</a>
                    </p>
                </div>
            </article>

            <nav id="post-nav">


            </nav>

            <script id="discus-javascript">
                var disqus_shortname = 'improbable';

                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
                    document.getElementsByTagName('body')[0].appendChild(dsq);
                })();
            </script>

            <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            <div id="disqus_thread"></div>
        </section>

        <footer id="site-footer" class="nocontent">
            <p>
                This site is purely my personal work and does not reflect the views of my employer.
            </p>
            <p class="license">
                <a class="icon" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png"></a>
                This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
            </p>
        </footer>

        <script async src="/static/js/common.js"></script>
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" integrity="sha256-hj+5FRlAuvAFANiefn0PpJYCkV1X4QT9EgiPd+6QnCw=" crossorigin="anonymous"></script>
    </body>
</html>
