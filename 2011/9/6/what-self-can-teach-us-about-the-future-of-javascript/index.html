<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>What Self can teach us about the future of JavaScript</title>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="/static/css/main.min.css" type="text/css" media="all">
        <!--[if lte IE 8]>
            <link
                rel="stylesheet"
                href="/static/css/ie-fixes.css"
                type="text/css"
                media="all"
            />
            <script src="/static/js/html5shiv.js"></script>
        <![endif]-->

        <meta http-equiv="last-modified" content="Tue, 06 Sep 2011 15:45:46 GMT">
        <link rel="alternate" type="application/atom+xml" title="All Posts (Atom)" href="/feeds/all.atom">
        <link rel="alternate" type="application/rss+xml" title="All Posts (RSS)" href="/feeds/all.rss">
        <link rel="icon" type="image/jpeg" sizes="287x287" href="/static/img/favicon-287x287.jpg">
        <link rel="icon" type="image/jpeg" sizes="128x128" href="/static/img/favicon-128x128.jpg">
    </head>
    <body class="blog post_detail" itemscope itemtype="http://schema.org/BlogPosting">
        <nav id="site-nav">
            <header id="about">
                <h1><a href="/about/">Chris Adams</a></h1>
                <h2>Programmer, cyclist, photographer</h2>
            </header>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/feeds/all.atom" title="Site Feed">Site Feed</a>
                </li>
            </ul>
            <ul class="social-networks">
                <li>
                    <a rel="me" href="https://code4lib.social/@acdha">Mastodon</a>
                </li>
                <li>
                    <a href="https://github.com/acdha" rel="me">Github</a>
                </li>
                <li>
                    <a href="https://bitbucket.org/acdha" rel="me">Bitbucket</a>
                </li>
                <li>
                    <a href="https://pinboard.in/u:acdha/" rel="me">Pinboard</a>
                </li>
                <li>
                    <a href="https://www.flickr.com/photos/acdha" rel="me">Flickr</a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/in/acdha" rel="me">LinkedIn</a>
                </li>
            </ul>
            <div id="site-search"></div>
        </nav>
        <section id="main">
            <article class="post">
                <header>
                    <meta itemprop="dateCreated" content="2011-09-06T11:45:46-04:00">
                    <meta itemprop="dateModified" content="2011-09-06T11:45:46-04:00">
                    <time class="date" itemprop="datePublished" datetime="2011-09-06T15:45:46+00:00">Sep 06</time>
                    <h2 class="" itemprop="title">What Self can teach us about the future of JavaScript</h2>
                </header>

                <div class="body" itemprop="articleBody"><div class="googlereader description" data-google-id="tag:google.com,2005:reader/item/e62eb28b77a781d5">
                        <blockquote>
                            <p>
                                Much of Computer Science research never materializes in the practical, real world of PHP pages, Bash scripts and moving CSV files over FTP. Some, though, ends up re-discovered and in daily use ever since. This is one such story.
                            </p>
                            <p>
                                Like many other language/UI innovations, <a href="http://en.wikipedia.org/wiki/Self_(programming_language)">Self</a> came to life at Xerox PARC, back in 1986. The wonderful <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.86.9441&amp;rep=rep1&amp;type=pdf">Programming as an Experience: The Inspiration for Self</a> article that I’m liberally quoting here is dated 1995. You may remember 1995 as the year Netscape shipped Navigator 2.0 and with it <a href="http://oreilly.com/pub/a/javascript/2001/04/06/js_history.html">JavaScript</a>, a language inspired by Self and Scheme.
                            </p>
                            <p>
                                What did the future look like back then? What has changed in those 25 years? And what can we learn to save us from yet another delayed re-discovery?
                            </p>
                            <p>
                                <strong>Maps and prototypes</strong>
                            </p>
                            <p>
                                The underlying data structures in Self are maps and prototypes:
                            </p>
                            <blockquote>
                                <p>
                                    A computation in Self consists solely of objects which in turn consist of slots. A slot has a name and a value. Slot names are always strings, but slot values can be any Self object. A slot can be marked with an asterisk to show that it designates a parent. … When sending a message, if no slot name matches within the receiving object, its parent’s slots are searched, and then slots in the parent’s parent, and so on.
                                </p>
                            </blockquote>
                            <p>
                                Maps (or their concrete type hash-table) have been a fundamental data structures since before the epoch. They’re used by every object-oriented language, but many languages complicate and then hide them underneath a pile of higher level abstractions. Try the Java Reflection API, or enumerating object/class methods/variables associated with a Ruby object, you’ll see what I mean.
                            </p>
                            <p>
                                I’d go further and claim in recent years maps have made the leap from blue-collar data structure into a key architecture pattern. Maps are the basis for <a href="http://json.org/">exchanging information</a>, <a href="http://en.wikipedia.org/wiki/Key-value_store#Key-value_store">solving big data storage</a> and <a href="http://en.wikipedia.org/wiki/Distributed_hash_table">coordinating large-scale distributed systems</a>.
                            </p>
                            <p>
                                I’m hoping prototypes will emerge as fundamental, though we’re not there yet. I guess it’s the combination of developers still thinking in terms of Class-Inheritance coupling, and not enough examples that put prototypes to good use.
                            </p>
                            <p>
                                <strong>View Source</strong>
                            </p>
                            <p>
                                Self is a language rooted in its environment, and the Self environment is about exploring and directly manipulating objects. It’s called “Live editing”:
                            </p>
                            <blockquote>
                                <p>
                                    Live editing is partly a result of having an interactive system, but is enhanced by features in the user interface. This principle reinforces the feel that the programmer is working directly with concrete objects. The following example will clarify how this principle and the structural reification principle help give the programmer a feeling of a working in a uniform world of accessible, tangible objects.
                                </p>
                                <p>
                                    …
                                </p>
                                <p>
                                    It is important to note that during this whole process, the simulation could be left running — there was no fundamental need to enter an “edit” mode, or even stop the atoms from bouncing around. The live editing principle makes the system feel responsive, and is reminiscent of the physical world’s concrete presence. Structural reification means that the parts of the interface are visible and accessible for direct modification.
                                </p>
                            </blockquote>
                            <p>
                                Sounds familiar? If you’re reading this on Chrome or Safari, pick any element on the page and right click on Inspect Element. You can manipulate any object, change its properties, bind new methods, all without stopping scripts from executing.
                            </p>
                            <p>
                                I heard people complain of a mismatch between DOM and a proper abstraction for composing interactive UIs. Then again, what other environments makes it possible for every user to reach into the UI and manipulate at will? Can you think of a better way to allow <a href="http://userscripts.org/">infinite customization</a> and <a href="http://www.shirky.com/writings/view_source.html">learning by experience</a>?
                            </p>
                            <p>
                                This, direct manipulation without layers of indirection and complex tooling, is how we get more people to program.
                            </p>
                            <p>
                                <strong>Minimalism of expression</strong>
                            </p>
                            <p>
                                Self is a minimalistic language, and here lies a lesson for language designers and <a href="http://www.mikealrogers.com/posts/remember-with.html">the future of JavaScript</a>:
                            </p>
                            <blockquote>
                                <p>
                                    Why have we tried to keep the Self language minimal? It is always tempting to add a new feature that handles some example better. Although the feature had made it possible to directly handle some examples, the burden it imposed in all reasoning about programs was just too much. … Although adding features seems good, every new concept burdens every programmer who comes into contact with the language.
                                </p>
                                <p>
                                    We have learned the hard way that smaller is better and that examples can be deceptive. … We now believe that when features, rules, or elaborations are motivated by particular examples, it is a good bet that their addition will be a mistake. The second author once coined the term “architect’s trap” for something similar in the field of computer architecture; this phenomenon might be called “the language designer’s trap.”
                                </p>
                            </blockquote>
                            <p>
                                <strong>The Architect’s Trap</strong>. Learn to avoid it.
                            </p>
                            <p>
                                It turns out there are far more valuable traits than “every possible feature”:
                            </p>
                            <blockquote>
                                <p>
                                    If examples cannot be trusted, what do we think should motivate the language designer? Consistency and malleability. When there is only one way of doing things, it is easier to modify and reuse code. When code is reused, programs are easier to change and most importantly, shrink. When a program shrinks its construction and maintenance requires fewer people which allows for more opportunities for reuse to be found. Consistency leads to reuse, reuse leads to conciseness, conciseness leads to understanding. That is why we feel that it is hard to justify any type system that impedes reusability; the resultant duplication leads to a bigger program that is then harder to understand and to get right. Such type systems can be self-defeating.
                                </p>
                            </blockquote>
                            <p>
                                The lesson here is not just for language designers. Consistency and malleability will make your API/library better, it will help you build frameworks and modularize large apps, expose and consume remote services.
                            </p>
                            <p>
                                <strong>Optimize for people, not machines</strong>
                            </p>
                            <p>
                                Minimal languages lack declarations, whether types, annotations or other compiler performance crutches:
                            </p>
                            <div>
                                <blockquote>
                                    <p>
                                        Self’s design departs significantly from other object-oriented languages by separating information needed to run the program from information about the programmer’s intentions. It distinguishes abstract types, used for the programmers understanding and reasoning about correctness, from concrete types, used to run and optimize the program. The former is left to the environment, the latter is left to the implementation. In our opinion, this approach avoids a number of undesirable consequences that often follow from attempts to integrate these two forms of information.
                                    </p>
                                </blockquote>
                                <p>
                                    Self tackles performance by coupling an interpreter and an optimizing compiler with type-feedback, and switching between the two as necessary. Sounds familiar? You might be thinking of <a href="http://wingolog.org/archives/2011/08/02/a-closer-look-at-crankshaft-v8s-optimizing-compiler">Chrome’s V8 Crankshaft compiler</a>.
                                </p>
                                <p>
                                    Why go to all that trouble?
                                </p>
                                <blockquote>
                                    <p>
                                        Along the way Self’s implementation techniques of adaptive recompilation and type-feedback achieve some traditionally-important but rarely achieved goals as well: the elimination of run-time penalty for factoring and for user-defined control structures. A programmer may chop up a method as finely as desired without slowing it down, and may introduce new abstractions that combine control and data without paying a run-time price. These characteristics encourage the create of programmers that are smaller and more malleable.
                                    </p>
                                </blockquote>
                                <p>
                                    That’s why.
                                </p>
                                <p>
                                    <strong>In conclusion</strong>
                                </p>
                                <p>
                                    What I found most interesting about JavaScript and Self were not the language similarities, but how language and environment come together to achieve a common goal: to create an environment that is malleable, that allows learning through sharing and exploration, that uses minimalism and consistency to foster reuse.
                                </p>
                                <p>
                                    25 years later, it’s part and parcel of every modern browser.
                                </p>
                                <p>
                                    And my message to future JavaScript is, “keep it simple”:
                                </p>
                                <blockquote>
                                    <p>
                                        Minimalism, simplicity and consistency are better guides. They benefit every programmer, not just the ones who need advanced features. We suspect that many of today’s object-oriented languages could profit by dropping features.
                                    </p>
                                </blockquote>
                                <p>
                                     
                                </p>
                            </div>
                        </blockquote>
                    </div>
                    <p class="bookmark-source">
                        Source: <a href="http://labnotes.org/2011/09/06/what-self-can-teach-us-about-the-future-of-javascript/">http://labnotes.org/2011/09/06/what-self-can-teach-us-about-the-future-of-javascript/</a>
                    </p>
                </div>
            </article>

            <nav id="post-nav">


            </nav>
        </section>

        <footer id="site-footer" class="nocontent">
            <p>
                This site is purely my personal work and does not reflect the
                views of my employer.
            </p>
            <p class="license">
                <a class="icon" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png"></a>
                This work is licensed under a
                <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported
                    License</a>.
            </p>
        </footer>

        <script async src="/static/js/common.js"></script>
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" integrity="sha256-hj+5FRlAuvAFANiefn0PpJYCkV1X4QT9EgiPd+6QnCw=" crossorigin="anonymous"></script>
    </body>
</html>
