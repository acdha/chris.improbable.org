<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>
            A Tough Design Decision
        </title>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="/static/css/main.min.css" type="text/css" media="all"><!--[if lte IE 8]>
            <link rel="stylesheet" href="/static/css/ie-fixes.css" type="text/css" media="all">
            <script src="/static/js/html5shiv.js"></script>
        <![endif]-->
        <meta http-equiv="last-modified" content="Sat, 22 Jan 2011 03:09:32 GMT">
        <link rel="alternate" type="application/atom+xml" title="All Posts (Atom)" href="/feeds/all.atom">
        <link rel="alternate" type="application/rss+xml" title="All Posts (RSS)" href="/feeds/all.rss">
        <link rel="icon" type="image/jpeg" sizes="287x287" href="/static/img/favicon-287x287.jpg">
        <link rel="icon" type="image/jpeg" sizes="128x128" href="/static/img/favicon-128x128.jpg">
        <script type="application/javascript">
var _prum={id:"5166be01e6e53d1007000001"};var PRUM_EPISODES=PRUM_EPISODES||{};PRUM_EPISODES.q=[];PRUM_EPISODES.mark=function(b,a){PRUM_EPISODES.q.push(["mark",b,a||new Date().getTime()])};PRUM_EPISODES.measure=function(b,a,b){PRUM_EPISODES.q.push(["measure",b,a,b||new Date().getTime()])};PRUM_EPISODES.done=function(a){PRUM_EPISODES.q.push(["done",a])};PRUM_EPISODES.mark("firstbyte");(function(){var b=document.getElementsByTagName("script")[0];var a=document.createElement("script");a.type="text/javascript";a.async=true;a.charset="UTF-8";a.src="//rum-static.pingdom.net/prum.min.js";b.parentNode.insertBefore(a,b)})();
        </script>
    </head>
    <body class="blog post_detail" itemscope itemtype="http://schema.org/BlogPosting">
        <nav id="site-nav">
            <header id="about">
                <h1>
                    <a href="/about/">Chris Adams</a>
                </h1>
                <h2>
                    Programmer, cyclist, photographer
                </h2>
            </header>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/feeds/all.atom" title="Site Feed">Site Feed</a>
                </li>
            </ul>
            <ul class="social-networks">
                <li>
                    <a href="https://github.com/acdha" rel="me">Github</a>
                </li>
                <li>
                    <a href="http://bitbucket.org/acdha" rel="me">Bitbucket</a>
                </li>
                <li>
                    <a href="http://delicious.com/acdha" rel="me">del.icio.us</a>
                </li>
                <li>
                    <a href="http://twitter.com/acdha" rel="me">Twitter</a>
                </li>
                <li>
                    <a href="https://plus.google.com/116562742092842686896?rel=author" rel="me">Google+</a>
                </li>
                <li>
                    <a href="http://www.flickr.com/photos/acdha" rel="me">Flickr</a>
                </li>
                <li>
                    <a href="http://www.linkedin.com/in/acdha" rel="me">LinkedIn</a>
                </li>
                <li>
                    <a href="http://connect.garmin.com/explore?owner=acdha" rel="me">Garmin Connect</a>
                </li>
            </ul>
            <div id="site-search"></div>
        </nav>
        <section id="main">
            <article class="post">
                <header>
                    <meta itemprop="dateCreated" content="2011-01-21T22:09:32-04:00">
                    <meta itemprop="dateModified" content="2011-01-21T22:09:32-04:00"><time class="date" itemprop="datePublished" datetime="2011-01-22T02:09:32+00:00">Jan 22</time>
                    <h2 itemprop="title">
                        A Tough Design Decision
                    </h2>
                </header>
                <div class="body" itemprop="articleBody">
                    <div class="googlereader description" data-google-id="tag:google.com,2005:reader/item/50b004d7b91150d8">
                        <blockquote>
                            <p>
                                When I set out to work on <a href="https://github.com/gulopine/biwako">Biwako</a>, I expected to have to make some hard choices, but I didn’t expect to hit one so quickly. What started as a simple feature turned out to take several days of research, trial and error before finally settling on a solution that I didn’t see coming. And in the spirit of building this framework out in the open, I’d like to spend some time sharing my experiences, in hopes of helping someone else who might face a similar problem&nbsp;someday.
                            </p>
                            <p>
                                Yesterday, <a href="http://martyalchin.com/2011/jan/20/class-level-keyword-arguments/">I explained</a> how Python allows a class declaration to take keyword arguments alongside the usual base class. For Biwako, I planned to use that to use that feature as a way to keep things <abbr title="Don't Repeat Yourself"><span>DRY</span></abbr>. Some field types have options that are the same for all such fields within the same file format. It doesn’t make sense to have to specify the same option over and over again, when it can instead be supplied at the class&nbsp;level.
                            </p>
                            <p>
                                So the goal is to provide arguments to the class that will then be passed into each of the fields that needs it. That puts it in a different category than, for instance, Django’s <a href="http://docs.djangoproject.com/en/1.2/ref/models/options/"><code>Meta</code> options</a>. Sure, some of those are accessed by fields, but they describe the model class itself. For Biwako, the options are much more tightly integrated with the fields themselves, which poses something of a&nbsp;problem.
                            </p>
                            <h2>
                                The naïve&nbsp;approach
                            </h2>
                            <p>
                                To illustrate why it’s a problem, let’s start with what I’ll call the naïve approach. The most straightforward solution I could think of, just to try to get the thing working. Basically, let Python process the <code>Structure</code> class declaration the way it normally would, then use the <code>attach_to_class()</code> method to retrieve the extra arguments from the&nbsp;class.
                            </p>
                            <p>
                                First, a quick moment to explain <code>attach_to_class()</code> if you’re not familiar with it. Once Python has executed the body of the <code>Structure</code> class declartion, the metaclass for <code>Structure</code> will loop through all the class attributes, looking for any that have an <code>attach_to_class()</code> method. When one is found, the metaclass calls the method and passes it the class object and the name that the field was assigned&nbsp;to.
                            </p>
                            <p>
                                Without this step, fields have no way to know what name they were given, so it’s a necessity in any declarative framework like this. The <a href="http://martyalchin.com/2007/nov/12/using-declarative-syntax-part-3/">last time I covered declarative syntax</a>, I only used this step to set the name, but this is also the first opportunity the field has to see the class it was assigned to, so it’s advantageous to pass that in as well. So to start, the <code>attach_to_class()</code> method looks something like&nbsp;this:
                            </p>
                            <div>
                                <pre>
<span>class</span> <span>Field</span><span>:</span>

    <span># ...</span>

    <span>def</span> <span>attach_to_class</span><span>(</span><span>self</span><span>,</span> <span>cls</span><span>,</span> <span>name</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        <span>label</span> <span>=</span> <span>self</span><span>.</span><span>label</span> <span>or</span> <span>name</span><span>.</span><span>replace</span><span>(</span><span>'_'</span><span>,</span> <span>' '</span><span>)</span>
        <span>self</span><span>.</span><span>label</span> <span>=</span> <span>label</span><span>.</span><span>title</span><span>()</span>
        <span>cls</span><span>.</span><span>_fields</span><span>.</span><span>append</span><span>(</span><span>self</span><span>)</span>
</pre>
                            </div>
                            <p>
                                So here it’s dealing with the name and assigning itself to a list of known fields. But this gets called from the <code>__init__()</code> method of the metaclass, which, as I explained yesterday, has all the class keyword arguments available to it. So if I pass those into <code>attach_to_class()</code> as well, the field can pick out which options it knows about and use them however it needs to. So for integers that take an <code>endianness</code> argument:
                            </p>
                            <div>
                                <pre>
<span>class</span> <span>Integer</span><span>(</span><span>Field</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>endianness</span><span>=</span><span>BigEndian</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>super</span><span>(</span><span>Integer</span><span>,</span> <span>self</span><span>)</span><span>.</span><span>__init__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>endianness</span> <span>=</span> <span>endianness</span><span>(</span><span>self</span><span>.</span><span>size</span><span>)</span>

    <span># ...</span>

    <span>def</span> <span>attach_to_class</span><span>(</span><span>self</span><span>,</span> <span>cls</span><span>,</span> <span>name</span><span>,</span> <span>endianness</span><span>=</span><span>BigEndian</span><span>,</span> <span>**</span><span>options</span><span>):</span>
        <span>self</span><span>.</span><span>endianness</span> <span>=</span> <span>endianness</span><span>(</span><span>self</span><span>.</span><span>size</span><span>)</span>
        <span>super</span><span>(</span><span>Integer</span><span>,</span> <span>self</span><span>)</span><span>.</span><span>attach_to_class</span><span>(</span><span>cls</span><span>,</span> <span>name</span><span>,</span> <span>**</span><span>options</span><span>)</span>
</pre>
                            </div>
                            <p>
                                But wait, why do <code>__init__()</code> and <code>attach_to_class()</code> <em>both</em> take an <code>endianness</code> argument? Well, <code>__init__()</code> always has to accept it in case you want to specify it explicitly, for those rare formats where endianness might not be uniform throughout the file. So by adding options to <code>attach_to_class()</code> without updating <code>__init__()</code>, what happens now is inconsistent. If you supply <code>endianness</code> to just the class, it will work as you expect, but if you put it in the field instead, you get&nbsp;this:
                            </p>
                            <ol>
                                <li>The field instantiates with the explicit endianness value and stores it&nbsp;away.
                                </li>
                                <li>The class comes along and overrides it with its default value, because <code>attach_to_class()</code> comes&nbsp;later.
                                </li>
                            </ol>
                            <p>
                                And if you happen to supply it in both places, it goes something like&nbsp;this:
                            </p>
                            <ol>
                                <li>The field stores away its endianness value&nbsp;correctly.
                                </li>
                                <li>The class comes along and overrides it with the value it was&nbsp;given.
                                </li>
                            </ol>
                            <p>
                                So really, the field value is getting the shaft no matter what. The only time it works the right way is when you don’t pass anything into the field at all. So in order to make it work properly, <code>attach_to_class()</code> needs to figure out whether the argument was passed into the field or not. If it was, the class-level argument should be ignored, regardless of whether something was passed in&nbsp;explicitly.
                            </p>
                            <p>
                                Of course, the simplest way to do that is to take the default value out of <code>__init__()</code> and use <code>None</code> instead. That way, <code>attach_to_class()</code> can check if the attribute is set to <code>None</code> or something more specific. Only in the former case should it bother supplying its own&nbsp;value.
                            </p>
                            <div>
                                <pre>
<span>class</span> <span>Integer</span><span>(</span><span>Field</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>endianness</span><span>=</span><span>None</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>endianness</span> <span>=</span> <span>endianness</span>
        <span>super</span><span>(</span><span>Integer</span><span>,</span> <span>self</span><span>)</span><span>.</span><span>__init__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>

    <span># ...</span>

    <span>def</span> <span>attach_to_class</span><span>(</span><span>self</span><span>,</span> <span>cls</span><span>,</span> <span>name</span><span>,</span> <span>endianness</span><span>=</span><span>BigEndian</span><span>,</span> <span>**</span><span>options</span><span>):</span>
        <span>if</span> <span>self</span><span>.</span><span>endianness</span> <span>is</span> <span>None</span><span>:</span>
            <span>self</span><span>.</span><span>endianness</span> <span>=</span> <span>endianness</span>
        <span># Still need to initialize it</span>
        <span>self</span><span>.</span><span>endianness</span> <span>=</span> <span>self</span><span>.</span><span>endianness</span><span>(</span><span>self</span><span>.</span><span>size</span><span>)</span>
        <span>super</span><span>(</span><span>Integer</span><span>,</span> <span>self</span><span>)</span><span>.</span><span>attach_to_class</span><span>(</span><span>cls</span><span>,</span> <span>name</span><span>,</span> <span>**</span><span>options</span><span>)</span>
</pre>
                            </div>
                            <p>
                                Now, believe it or not, this works. It correctly handles all four combinations of where arguments could be passed in. But it has two fairly severe&nbsp;problems:
                            </p>
                            <ul>
                                <li>
                                    <p>
                                        It’s ugly. File formats are often heavily customized, so custom fields are likely to be a big part of the Biwako ecosystem. If I’m asking my users to create their own custom fields very often, I’d like the <span>API</span> for it to be nicer, more straightforward and less prone to simple mistakes (like supplying a default value in <code>__init__()</code> even though that’s exactly what you’d normally&nbsp;do).
                                    </p>
                                </li>
                                <li>
                                    <p>
                                        It’s difficult to test. When writing unit tests for fields, it’s a lot better to instantiate the fields on their own, without being part of a class declaration. That way you have less parts involved and you can focus on testing just what you’re worried about. But if endianness isn’t set and instantiated until <code>attach_to_class()</code> is executed, those independent fields are pretty much&nbsp;useless.
                                    </p>
                                </li>
                            </ul>
                            <p>
                                These problems were enough to make me quickly realize that I needed a better solution. I figured I’d have a few options, so I wanted to spend the time to find out what I could do and how it would work. I started where you probably expected me to start. More&nbsp;metaclasses.
                            </p>
                            <h2>
                                The declarative&nbsp;approach
                            </h2>
                            <p>
                                You’ve probably noticed by now that I’m a big fan of declarative classes, so it shouldn’t be too surprising that my first instinct was to make another one. I figured that the arguments themselves could be pulled out of the methods and assigned as attributes to the <code>Field</code> class, just like fields are assigned to <code>Structure</code> classes. So <code>Integer</code> would look something like&nbsp;this:
                            </p>
                            <div>
                                <pre>
<span>class</span> <span>Integer</span><span>(</span><span>Field</span><span>):</span>
    <span>endianness</span> <span>=</span> <span>Argument</span><span>(</span><span>default</span><span>=</span><span>BigEndian</span><span>)</span>

    <span># ...</span>
</pre>
                            </div>
                            <p>
                                Behind the scenes, though, things would work a lot like the naïve approach. <code>__init__()</code> would be able to tell if an argument was pass in and <code>attach_to_class()</code> would figure out if it needed to override the attribute or not. The only real difference is that the arguments would come from the class declaration, which saves users the trouble of seeing the whole <code>__init__()</code>/<code>attach_to_class()</code> mess.
                            </p>
                            <p>
                                That’s certainly prettier, and it uses a syntax I’m already expecting my users to be familiar with, so it seemed promising. But there’s another half of the problem: initializing fields on their own, outside of a <code>Structure</code>. As it stands, I’d still be left with undefined attributes if I wanted to use the&nbsp;defaults.
                            </p>
                            <p>
                                So I then took advantage of the fact that class attributes, such as the <code>Argument</code> object in the above example, can be used as <a href="http://martyalchin.com/2007/nov/23/python-descriptors-part-1-of-2/">descriptors</a>. That way, the field can figure out when the testing code is trying to access it. If it doesn’t have an explicit value yet, the descriptor can provide a default, which was naturally already passed into it as an argument (to … <code>Argument</code> … yeah, its arguments <a href="http://en.wikipedia.org/wiki/Turtles_all_the_way_down">all the way down</a>, stay with&nbsp;me).
                            </p>
                            <div>
                                <pre>
<span>class</span> <span>Argument</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>default</span><span>=</span><span>None</span><span>):</span>
        <span>self</span><span>.</span><span>default</span> <span>=</span> <span>default</span>

    <span># ...</span>

    <span>def</span> <span>__get__</span><span>(</span><span>self</span><span>,</span> <span>instance</span><span>,</span> <span>owner</span><span>):</span>
        <span>if</span> <span>self</span><span>.</span><span>name</span> <span>not</span> <span>in</span> <span>instance</span><span>.</span><span>__dict__</span><span>:</span>
            <span># Default value to the rescue!</span>
            <span>instance</span><span>.</span><span>__dict__</span><span>[</span><span>self</span><span>.</span><span>name</span><span>]</span> <span>=</span> <span>self</span><span>.</span><span>default</span>
        <span>return</span> <span>instance</span><span>.</span><span>__dict__</span><span>[</span><span>self</span><span>.</span><span>name</span><span>]</span>
</pre>
                            </div>
                            <p>
                                So far, so good. If the field gets instantiated outside a class, it doesn’t know that at first, but as soon as one of its arguments is accessed, it quickly sets a default value if it needs to and allows the field to act as if it knew all along how it was supposed to&nbsp;work.
                            </p>
                            <p>
                                You’ll notice one key feature went missing, though: the argument can’t be initialized. The way it stands, if I were to pass in <code>endianness=BigEndian</code>, the endianness value would end up being the <code>BigEndian</code> class, rather than an instance of that class that’s been tailored to the field’s size. So we need a way to specify an initialization function for each argument as&nbsp;well.
                            </p>
                            <p>
                                For that, I turned to a decorator. In the class declaration, the <code>endianness</code> argument gets instantiated as an object right away. I can then add a method on that object to act as a decorator, which will allow users to mark a field method as being the initialization function for the&nbsp;argument.
                            </p>
                            <div>
                                <pre>
<span>class</span> <span>Argument</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>default</span><span>=</span><span>None</span><span>):</span>
        <span>self</span><span>.</span><span>default</span> <span>=</span> <span>default</span>
        <span># A default initializer that does nothing</span>
        <span>self</span><span>.</span><span>initialize</span> <span>=</span> <span>lambda</span> <span>obj</span><span>,</span> <span>value</span><span>:</span> <span>value</span>

    <span># ...</span>

    <span>def</span> <span>__get__</span><span>(</span><span>self</span><span>,</span> <span>instance</span><span>,</span> <span>owner</span><span>):</span>
        <span>if</span> <span>self</span><span>.</span><span>name</span> <span>not</span> <span>in</span> <span>instance</span><span>.</span><span>__dict__</span><span>:</span>
            <span># Default value to the rescue!</span>
            <span>value</span> <span>=</span> <span>self</span><span>.</span><span>initialize</span><span>(</span><span>instance</span><span>,</span> <span>self</span><span>.</span><span>default</span><span>)</span>
            <span>instance</span><span>.</span><span>__dict__</span><span>[</span><span>self</span><span>.</span><span>name</span><span>]</span> <span>=</span> <span>value</span>
        <span>return</span> <span>instance</span><span>.</span><span>__dict__</span><span>[</span><span>self</span><span>.</span><span>name</span><span>]</span>

    <span>def</span> <span>init</span><span>(</span><span>self</span><span>,</span> <span>func</span><span>):</span>
        <span>self</span><span>.</span><span>initialize</span> <span>=</span> <span>func</span>
        <span>return</span> <span>func</span>

<span># ...</span>

<span>class</span> <span>Integer</span><span>(</span><span>Field</span><span>):</span>
    <span>endianness</span> <span>=</span> <span>Argument</span><span>(</span><span>default</span><span>=</span><span>BigEndian</span><span>)</span>

    <span>@endianness</span><span>.</span><span>init</span>
    <span>def</span> <span>initialize_endianness</span><span>(</span><span>self</span><span>,</span> <span>endianness</span><span>):</span>
        <span>return</span> <span>endianness</span><span>(</span><span>self</span><span>.</span><span>size</span><span>)</span>

    <span># ...</span>
</pre>
                            </div>
                            <p>
                                Of course, there are other places where this new <code>initialize()</code> function would get called, but you get the idea. Now we have a way to populate arguments from two different places, give them default values, and initialize whatever values are being used. It’s certainly a prettier, friendlier approach and it works great with tests. But it has its own&nbsp;caveats:
                            </p>
                            <ul>
                                <li>
                                    <p>
                                        It’s surprisingly fragile. If you were to provide your own <code>__init__()</code> method and try to use the argument too early, the default value would get stored before the class has a chance to provide its value, and there’d be no way for the <code>Argument</code> class to know whether that was intentional or&nbsp;accidental.
                                    </p>
                                </li>
                                <li>
                                    <p>
                                        It’s counter-intuitive. It might be pretty, but the fact remains that we’ve introduced a declarative syntax in order to handle what would seem like a common situation: passing an argument into a function. It requires users to “unlearn” what they’ve learned, and I don’t think that’s a good thing to be&nbsp;doing.
                                    </p>
                                </li>
                                <li>
                                    <p>
                                        It’s <a href="http://en.wikipedia.org/wiki/Law_of_the_instrument">Maslow’s hammer</a>. If all you have is a hammer, everything looks like a nail. I have more than just declarative syntax at my disposal, so it feels wrong to just jump straight to it whenever I’m faced with a problem. There’s got to be other options available, and one of them is probably more appropriate, especially given the previous&nbsp;point.
                                    </p>
                                </li>
                            </ul>
                            <p>
                                It’s easy to ignore that third point, and just figure that if something works, it must be the right tool for the job. In this case, it’s an extremely heavy-handed approach to an otherwise simple problem, and with my particular reliance on the declarative sytle, I really wanted to push myself to use something&nbsp;else.
                            </p>
                            <h2>
                                The&nbsp;placeholder
                            </h2>
                            <p>
                                So while I was working on the declarative approach, I thought of another possibilty. The real problem with the naïve approach is that it relied on a value of <code>None</code> to determine if an argument had been passed into the field or not, once <code>attach_to_class()</code> comes along. So what if I could use a different value instead? One that not only served the same purpose, but could also be used to manage a default&nbsp;value?
                            </p>
                            <p>
                                Basically, I’d use the field’s <code>__init__()</code> method like normal, but instead of passing in the argument’s default value directly, it could be wrapped up in a <code>Default</code> object (I actually called it <code>Arg</code> but I like <code>Default</code> better). Then <code>attach_to_class()</code> check for an instance of that object instead, and if found, grab the default value from the object itself and use&nbsp;that.
                            </p>
                            <div>
                                <pre>
<span>class</span> <span>Default</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>value</span><span>):</span>
        <span>self</span><span>.</span><span>default_value</span>

<span>class</span> <span>Field</span><span>:</span>
    <span># ...</span>

    <span>def</span> <span>attach_to_class</span><span>(</span><span>self</span><span>,</span> <span>cls</span><span>,</span> <span>name</span><span>,</span> <span>**</span><span>options</span><span>):</span>
        <span>self</span><span>.</span><span>name</span> <span>=</span> <span>name</span>
        <span>label</span> <span>=</span> <span>self</span><span>.</span><span>label</span> <span>or</span> <span>name</span><span>.</span><span>replace</span><span>(</span><span>'_'</span><span>,</span> <span>' '</span><span>)</span>
        <span>self</span><span>.</span><span>label</span> <span>=</span> <span>label</span><span>.</span><span>title</span><span>()</span>
        <span>cls</span><span>.</span><span>_fields</span><span>.</span><span>append</span><span>(</span><span>self</span><span>)</span>
        <span>for</span> <span>name</span><span>,</span> <span>value</span> <span>in</span> <span>options</span><span>:</span>
            <span>if</span> <span>hasattr</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>)</span> <span>and</span> \
              <span>isinstance</span><span>(</span><span>getattr</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>),</span> <span>Default</span><span>):</span>
                <span>setattr</span><span>(</span><span>self</span><span>,</span> <span>name</span><span>,</span> <span>value</span><span>.</span><span>default_value</span><span>)</span>

<span>class</span> <span>Integer</span><span>(</span><span>Field</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>endianness</span><span>=</span><span>Default</span><span>(</span><span>BigEndian</span><span>),</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>self</span><span>.</span><span>endianness</span> <span>=</span> <span>endianness</span>
        <span>super</span><span>(</span><span>Integer</span><span>,</span> <span>self</span><span>)</span><span>.</span><span>__init__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
</pre>
                            </div>
                            <p>
                                The <code>hasattr()</code> test is necessary because this will get <em>all</em> the options, regardless of whether any of them actually mean something to this particular&nbsp;field.
                            </p>
                            <p>
                                This approach works for the most part, but again the initialization bit has gone missing. Since the <code>Default</code> object gets created inside the function signatures, there’s no good place to put the initialization code. There are three options that I can&nbsp;see:
                            </p>
                            <ul>
                                <li>Create the <code>Default</code> object somewhere else, so it can be used as a&nbsp;decorator.
                                </li>
                                <li>Pass in the initialization function as another argument to <code>Default</code>.
                                </li>
                                <li>Add the initialization function to the <code>Default</code> object somewhere in the code of <code>__init__()</code>, before it gets&nbsp;accessed.
                                </li>
                            </ul>
                            <p>
                                None of those are very convenient for users implementing their own fields. Technically a fourth could be initializing the value in <code>attach_to_class()</code>, but then we’re back to having problems with&nbsp;testing.
                            </p>
                            <p>
                                All in all, I didn’t get very far into this one before abandoning it due to lack of flexibility for things like initialization. Providing a default value was easy enough, but it wasn’t long before things got considerably more hairly. So when I went back to the drawing board, I thought much&nbsp;simpler.
                            </p>
                            <h2>
                                Double&nbsp;initialization
                            </h2>
                            <p>
                                A thought had occured to me: what I’m really trying to do is initialize the arguments in two different places. The first happens when <code>__init__()</code> is called during the creation of the field object. The second happens inside of <code>attach_to_class()</code>. But ultimately it’s the same process either way, so why not just call <code>__init__()</code> twice?
                            </p>
                            <p>
                                This one works by storing away the arguments that were passed in when the field was created, then filling in class-level arguments wherever a field-level argument wasn’t passed in. So in order to avoid messing with <code>__init__()</code> on the field any more than I had to, I built a very small metaclass for fields to work with—much smaller than the declarative approach shown&nbsp;earlier.
                            </p>
                            <div>
                                <pre>
<span>class</span> <span>FieldMeta</span><span>(</span><span>type</span><span>):</span>
    <span>def</span> <span>__call__</span><span>(</span><span>cls</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span># This gets called before __new__() or __init__()</span>
        <span>field</span> <span>=</span> <span>super</span><span>(</span><span>FieldMeta</span><span>,</span> <span>cls</span><span>)</span><span>.</span><span>__call__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
        <span>field</span><span>.</span><span>_arguments</span> <span>=</span> <span>(</span><span>args</span><span>,</span> <span>kwargs</span><span>)</span>
        <span>return</span> <span>field</span>

<span>class</span> <span>Field</span><span>(</span><span>metaclass</span><span>=</span><span>FieldMeta</span><span>):</span>
    <span>def</span> <span>attach_to_class</span><span>(</span><span>self</span><span>,</span> <span>cls</span><span>,</span> <span>name</span><span>,</span> <span>**</span><span>options</span><span>):</span>
        <span>args</span><span>,</span> <span>kwargs</span> <span>=</span> <span>self</span><span>.</span><span>_arguments</span>
        <span>options</span><span>.</span><span>update</span><span>(</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>__init__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>options</span><span>)</span>

<span>class</span> <span>Integer</span><span>(</span><span>Field</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>endianness</span><span>=</span><span>BigEndian</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>super</span><span>(</span><span>Integer</span><span>,</span> <span>self</span><span>)</span><span>.</span><span>__init__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>endianness</span> <span>=</span> <span>endianness</span><span>(</span><span>self</span><span>.</span><span>size</span><span>)</span>
</pre>
                            </div>
                            <p>
                                So the way this works, when you create a field, it’s complete, right out of the box. It has the necessary default values, initialization happens in <code>__init__()</code> where it belongs, there are no pesky placeholders or strange syntax and it works just as well for testing as it does in real use. It’s a fairly clean, concise solution … except for one potential&nbsp;problem.
                            </p>
                            <p>
                                Ordinarily, <code>__init__()</code> is called exactly once for a given object. When it’s first created, <code>__init__()</code> gets a chance to set some of its values to their starting positions, making the object ready for general use. Doing this step twice won’t cause problems in most cases, especially since the field won’t really get used between the two calls to <code>__init__()</code>.
                            </p>
                            <p>
                                But what actually goes on in <code>__init__()</code> is entirely up to you. You might just set a few attributes and be done with it or you might add the field to some internal registry for later use. That latter option would be considered a side-effect: the code modifies something outside of its own scope, and that change persists even after the function is done&nbsp;executing.
                            </p>
                            <p>
                                If the code gets run twice, any side-effects would also occur twice, which could be a problem. In the case of a field registry, you would end up with each field occurring twice in the registry, which would definitely cause problems. And since there’s no obvious cue that <code>__init__()</code> would get called twice, such problems could be difficult to track down to their&nbsp;source.
                            </p>
                            <p>
                                What I really need is a way to just get access to the class-level arguments <em>before</em> the fields are created, so that I can just pass in the full, correct set of arguments the first time and save myself all this&nbsp;mess.
                            </p>
                            <h2>
                                Thread&nbsp;locals
                            </h2>
                            <p>
                                Now, if you’re familiar with programming, and if you’ve been following Django design discussions in particular, you might see the phrase “thread locals” and immediately jump to scenes of mass descruction, flesh being torn off from innocent bystanders and babies having their candy taken away. But I felt it was my responsibility to consider every&nbsp;option.
                            </p>
                            <p>
                                The foundation of this approach is actually a newer feature of metaclasses that I neglected to mention yesterday: the <code>__prepare__()</code> method. In Python 3, metaclasses can have a method called <code>__prepare__()</code>, which will get called <em>before</em> Python processes any of the contents of the class declaration. That is, before any of the fields have been created or initialized. Thankfully for us, <code>__prepare__()</code> also gets the same keyword argument dictionary as <code>__new__()</code> and <code>__init__()</code>, containing all the options that are declared at the top of the&nbsp;class.
                            </p>
                            <p>
                                With that information available so early on, it’s possible to store those options right away. But we need a good place to put them. Unfortunately, because <code>__prepare__()</code> gets called so early, it doesn’t have access to the class object yet (that hasn’t even been created yet). Instead, it gets the name of the class, a tuple of its base classes and the dictionary of keyword arguments. So we turn to <a href="http://docs.python.org/library/threading.html#threading.local">thread locals</a>.
                            </p>
                            <p>
                                In a nutshell, thread locals are a way to store data so that only the current thread can see it. That way, if more than one thread happens to be running the same code at about the same time, there won’t be any conflict between the two. Since a single thread can only run code sequentially, we can be sure that if we place those class-level options in thread-local storage, it’ll be available exactly when we need it, and only to the thread that should see&nbsp;it.
                            </p>
                            <p>
                                Then, when each field is called, it can look in thread-local storage to find any class-level arguments and combine them with its own arguments before calling <code>__init__()</code> in the first&nbsp;place.
                            </p>
                            <div>
                                <pre>
<span>import</span> <span>threading</span>

<span>class</span> <span>FieldMeta</span><span>(</span><span>type</span><span>):</span>
    <span>_registry</span> <span>=</span> <span>threading</span><span>.</span><span>local</span><span>()</span>
    <span>_registry</span><span>.</span><span>options</span> <span>=</span> <span>{}</span>

    <span>def</span> <span>__call__</span><span>(</span><span>cls</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>if</span> <span>FieldMeta</span><span>.</span><span>_registry</span><span>.</span><span>options</span><span>:</span>
            <span>options</span> <span>=</span> <span>FieldMeta</span><span>.</span><span>_registry</span><span>.</span><span>options</span><span>.</span><span>copy</span><span>()</span>
            <span>options</span><span>.</span><span>update</span><span>(</span><span>kwargs</span><span>)</span>
        <span>else</span><span>:</span>
            <span>options</span> <span>=</span> <span>kwargs</span>
        <span>return</span> <span>super</span><span>(</span><span>FieldMeta</span><span>,</span> <span>cls</span><span>)</span><span>.</span><span>__call__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>options</span><span>)</span>

<span>class</span> <span>Field</span><span>(</span><span>metaclass</span><span>=</span><span>FieldMeta</span><span>):</span>
    <span># ...</span>

<span>class</span> <span>Integer</span><span>(</span><span>Field</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>*</span><span>args</span><span>,</span> <span>endianness</span><span>=</span><span>BigEndian</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
        <span>super</span><span>(</span><span>Integer</span><span>,</span> <span>self</span><span>)</span><span>.</span><span>__init__</span><span>(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwargs</span><span>)</span>
        <span>self</span><span>.</span><span>endianness</span> <span>=</span> <span>endianness</span><span>(</span><span>self</span><span>.</span><span>size</span><span>)</span>

<span>class</span> <span>StructureMeta</span><span>(</span><span>type</span><span>):</span>
    <span>@classmethod</span>
    <span>def</span> <span>__prepare__</span><span>(</span><span>metacls</span><span>,</span> <span>name</span><span>,</span> <span>bases</span><span>,</span> <span>**</span><span>options</span><span>):</span>
        <span>FieldMeta</span><span>.</span><span>options</span><span>.</span><span>arguments</span> <span>=</span> <span>options</span>

        <span># ...</span>

    <span>def</span> <span>__init__</span><span>(</span><span>cls</span><span>,</span> <span>name</span><span>,</span> <span>bases</span><span>,</span> <span>attrs</span><span>,</span> <span>**</span><span>options</span><span>):</span>
        <span># ...</span>

        <span># Clean up the thread-local dictionary</span>
        <span>FieldMeta</span><span>.</span><span>options</span><span>.</span><span>arguments</span> <span>=</span> <span>{}</span>
</pre>
                            </div>
                            <p>
                                With this in place, each field has the opportunity to instantiate itself using <em>all</em> of the arguments that it needs, regardless of where they were specified, without requiring any special handling for the subclass. Initialization of arguments happens in <code>__init__()</code>, and that process happens exactly once per field, just like it should. Fields get their default values when creating them for testing, and they get their full options in real&nbsp;use.
                            </p>
                            <h2>
                                The&nbsp;decision
                            </h2>
                            <p>
                                So after going through this entire process (over about five days), I finally had to come to a decision. As much as I had expected to find something more traditional, it turned out that thread locals actually solved the problem more cleanly than any other. It made the <span>API</span> dead obvious by not changing anything, and it was actually pretty simple to&nbsp;implement.
                            </p>
                            <p>
                                So there you have it. Biwako uses thread locals, and now you know&nbsp;why.
                            </p>
                            <h2>
                                The moral of the&nbsp;story
                            </h2>
                            <p>
                                Now, this hasn’t been a story of thread locals, metaclasses, descriptors or anthing else. Really, I just wanted to show the design process. Writing a framework requires countless decisions like this, and they can sound really&nbsp;daunting.
                            </p>
                            <p>
                                Sometimes it can seem like framework authors just naturally have things they like and don’t like or that they somehow always have all the right answers. But the fact is, most of these decisions are the result of a lot of trial and error, soul searching and trying very hard to think of the user experience above all else. Design and usability doesn’t only have to be visual; <span>API</span> design uses many of the same&nbsp;principles.
                            </p>
                            <p>
                                So Think of your users. Research your options. Keep an open mind. Ride the wave and you might be surprised where the process takes&nbsp;you.
                            </p>
                        </blockquote>
                    </div>
                    <p class="bookmark-source">
                        Source: <a href="http://martyalchin.com/2011/jan/21/design-decision/">http://martyalchin.com/2011/jan/21/design-decision/</a>
                    </p>
                </div>
            </article>
            <nav id="post-nav"></nav><script id="discus-javascript">
    var disqus_shortname = 'improbable';

                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                    document.getElementsByTagName('body')[0].appendChild(dsq);
                })();
            </script><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            <div id="disqus_thread"></div>
        </section>
        <footer id="site-footer">
            <p>
                This site is purely my personal work and does not reflect the views of my employer.
            </p>
            <p class="license">
                <a class="icon" rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png"></a> This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
            </p>
        </footer><script async="" defer src="/static/js/common.js">
</script><script id="google-analytics">
    var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-2097834-1']);
            _gaq.push(['_setDomainName', 'improbable.org']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
    </body>
</html>
