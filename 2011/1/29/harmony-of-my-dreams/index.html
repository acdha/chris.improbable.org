<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Harmony Of My Dreams</title>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="/static/css/main.min.css" type="text/css" media="all">
        <!--[if lte IE 8]>
            <link rel="stylesheet" href="/static/css/ie-fixes.css" type="text/css" media="all">
            <script src="/static/js/html5shiv.js"></script>
        <![endif]-->

        <meta http-equiv="last-modified" content="Sat, 29 Jan 2011 18:49:13 GMT">
        <link rel="alternate" type="application/atom+xml" title="All Posts (Atom)" href="/feeds/all.atom">
        <link rel="alternate" type="application/rss+xml" title="All Posts (RSS)" href="/feeds/all.rss">
        <link rel="icon" type="image/jpeg" sizes="287x287" href="/static/img/favicon-287x287.jpg">
        <link rel="icon" type="image/jpeg" sizes="128x128" href="/static/img/favicon-128x128.jpg">
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-2097834-1', 'auto');
            ga('send', 'pageview');
        </script>
    </head>
    <body class="blog post_detail" itemscope itemtype="http://schema.org/BlogPosting">
        <nav id="site-nav">
            <header id="about">
                <h1><a href="/about/">Chris Adams</a></h1>
                <h2>Programmer, cyclist, photographer</h2>
            </header>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/feeds/all.atom" title="Site Feed">Site Feed</a>
                </li>
            </ul>
            <ul class="social-networks">
                <li>
                    <a href="https://github.com/acdha" rel="me">Github</a>
                </li>
                <li>
                    <a href="https://bitbucket.org/acdha" rel="me">Bitbucket</a>
                </li>
                <li>
                    <a href="https://pinboard.in/u:acdha/" rel="me">Pinboard</a>
                </li>
                <li>
                    <a href="https://twitter.com/acdha" rel="me">Twitter</a>
                </li>
                <li>
                    <a href="https://www.flickr.com/photos/acdha" rel="me">Flickr</a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/in/acdha" rel="me">LinkedIn</a>
                </li>
            </ul>
            <div id="site-search"></div>
        </nav>
        <section id="main">
            <article class="post">
                <header>
                    <meta itemprop="dateCreated" content="2011-01-29T13:49:13-04:00">
                    <meta itemprop="dateModified" content="2011-01-29T13:49:13-04:00">
                    <time class="date" itemprop="datePublished" datetime="2011-01-29T17:49:13+00:00">Jan 29</time>
                    <h2 class="" itemprop="title">Harmony Of My Dreams</h2>
                </header>

                <div class="body" itemprop="articleBody"><div class="googlereader description" data-google-id="tag:google.com,2005:reader/item/9334c83bbdf43453">
                        <p class="annotation">
                            Worth reading for anyone who's thought about what's clumsy in JavaScript
                        </p>
                        <blockquote>
                            <p>
                                Continuing in the vein of <a href="http://brendaneich.com/2010/11/paren-free/">paren-free</a>, I’d like to present a refreshed vision of <a href="https://mail.mozilla.org/pipermail/es-discuss/2008-August/003400.html">JavaScript Harmony</a>. This impressionist exercise is of course not canonical (not yet), but it’s not some random, creepy <a href="http://www.answers.com/main/ntquery?gwp=13&amp;s=fanfic">fanfic</a> either. Something like this could actually happen, likelier and better if done with your help (more on how at the end).
                            </p>
                            <p>
                                I’m blurring the boundaries between Ecma TC39′s current consensus-Harmony, straw proposals for Harmony that some on TC39 favor, and my ideas. On purpose, because I think JS needs some new <a href="http://www.dreamsongs.com/Files/DesignedAsDesignerExpanded.pdf">conceptual integrity</a>. It does not need play-it-safe design-by-committee, either of the “let’s union all proposals” kind (which won’t fly on TC39), or a blind “let’s intersect proposals and if the empty set remains, so be it” approach (which also won’t fly, but it’s the likelier bad outcome).
                            </p>
                            <p>
                                Anyway, it’s my blog, and my current dream. I hope you like it. Talk and dream back at me, and with any luck we’ll build a better Harmony-in-reality.
                            </p>
                            <h2>
                                little languages
                            </h2>
                            <p>
                                Calling JavaScript a little language is polite but false at this late date: <a href="http://wiki.ecmascript.org/lib/exe/fetch.php?id=start&amp;cache=cache&amp;media=resources:tc39-2010-062-rev5.doc">ES5.1</a> weighs in at over 100,000 words, with hundreds of nonterminals in the lexical and syntactic grammars.
                            </p>
                            <p>
                                I would say that the same goes for <a href="http://jashkenas.github.com/coffee-script/">CoffeeScript</a>, although I get the point in its use of the phrase “little language”: concise expression-language sugar for the lever-arm, using JS-in-full as implemented in all browsers as the fulcrum, for maximum productivity leverage. CoffeeScript is well done and more convenient to use than JS, provided you buy into the Python-esque significant space and the costs of generating JS from another source language. But semantically it’s still JS.
                            </p>
                            <p>
                                Could JS evolve to be a better “little language” in both surface and substance? Implementors and users will impose some fuzzy but obvious and (past the fuzz) hard limits. JS can’t evolve directly into something too different. For instance, I believe JS implementors on TC39 would reject significant space instead of curly braces, or a mandatory bottom-up parser with disambiguation magic.
                            </p>
                            <p>
                                Meanwhile, <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">polyfills</a> such as CoffeeScript (when not run as a server-side code generator) may become more widely used, pushing JS in different directions. Still, it will be hard for polyfills to beat native code implementation, &lt;script&gt; tag prefetching, and the other built-into-every-browser advantages of pure JS.
                            </p>
                            <p>
                                Whatever happens with polyfills, JS’s fitful progress over its life so far suggests that it can evolve further, and significantly. Such evolution requires growth in the short run, to solve the obvious web-imposed problem of backward compatibility.
                            </p>
                            <h2>
                                growing a language
                            </h2>
                            <p>
                                Maturing languages grow even without web-wide compatibility constraints, and JS is no exception. We should continue to <a href="http://www.google.com/url?sa=t&amp;source=web&amp;cd=1&amp;ved=0CBMQtwIwAA&amp;url=http%3A%2F%2Fvideo.google.com%2Fvideoplay%3Fdocid%3D-8860158196198824415&amp;rct=j&amp;q=growing%20a%20language%20guy%20steele&amp;ei=1AY0TeW5DI3SsAOZs_C2BQ&amp;usg=AFQjCNGQFOs3B18-QhIFHVEXEV54gPQFGw&amp;sig2=i4-HY3NLHTjgX9zma6yekA&amp;cad=rja">grow the language</a>, keeping support for old forms while adding new forms to help users themselves grow the language.
                            </p>
                            <p>
                                That last link is to a video of Guy Steele’s famous talk. Here’s a cleaned-up <a href="http://labs.oracle.com/features/tenyears/volcd/papers/14Steele.pdf">transcript</a>. One quote:
                            </p>
                            <blockquote>
                                <p>
                                    If we add hundreds of new things to the Java programming language, we will have<br>
                                    a huge language, but it will take a long time to get there. But if we add just a few<br>
                                    things—generic types, overloaded operators, and user defined types of light weight, for<br>
                                    use as numbers and small vectors and such—that are designed to let users make and add<br>
                                    things for their own use, I think we can go a long way, and much faster. We need to put<br>
                                    tools for language growth in the hands of the users.
                                </p>
                            </blockquote>
                            <p>
                                Look past the Java specifics. This applies deeply to JS as well. Empowering users to grow the language is why <a href="http://brendaneich.com/#modules">modules</a>, <a href="http://brendaneich.com/2010/11/proxy-inception/">proxies</a>, <a href="http://wiki.ecmascript.org/doku.php?id=strawman:binary_data">binary data</a>, and even an operators/literals/value-types <a href="http://wiki.ecmascript.org/doku.php?id=strawman:value_proxies">dark horse</a>, are high priorities for Harmony in my view. Which is not to say we shouldn’t add anything else. Because:
                            </p>
                            <blockquote>
                                <p>
                                    I hope that we can, in this way or some other way, design a programming language<br>
                                    where we don’t seem to spend most of our time talking and writing in words of just one<br>
                                    syllable.
                                </p>
                            </blockquote>
                            <p>
                                You can do anything with <code>function</code> in JS, but you shouldn’t have to — it over-taxes JS programmers and VM implementors to learn and optimize all the idiomatic patterns. Too much like writing with only one-syllable words.
                            </p>
                            <h2>
                                grow to shrink
                            </h2>
                            <p>
                                If we do this right, Harmony’s <a href="http://www.sics.se/~seif/Publications/fdp.pdf">kernel semantics</a> do not grow inordinately in complexity. Then users merely have to choose to use the simpler new syntax over the old, and for those users (and possibly for everyone, many years hence — sooner, if you use a translator to “lower” Harmony to JS-as-it-is), JS is in fact more usable and smaller in its critical dimensions.
                            </p>
                            <p>
                                Beyond users choosing to code in a subset, we could potentially shrink — or not grow, or grow less — the opt-in Harmony language by excluding misfeatures of “classic JS”. This was one of the ideas developed in <a href="http://brendaneich.com/2010/11/paren-free/">paren-free</a> and some followup comments: no messy, underspecified, not-quite-interoperable <code>for (i in o)</code> loop, only <code>for i in o</code> loops, comprehensions, and generator expressions, to take one example. ES5 strict mode already removes <code>with</code>. Harmony already proposes to remove the global object as top-most scope, to pick a non-syntactic example.
                            </p>
                            <p>
                                (Opt-in is required for Harmony because of new syntax. Yet developer brain-print conservation, existing code migration, shared-object-heap interoperation, and browser engine code re-use, all favor keeping Harmony “close” to JS-as-it-is. How close is the question. I’m in favor of pushing this envelope given the inertia of the standards setting and the conservatism of committees. Bear with me if you disagree.)
                            </p>
                            <p>
                                On the web, the only way to shrink is to grow first. As I put it at <a href="http://brendaneich.com/2010/07/a-brief-history-of-javascript/">jsconf.us</a> last year, provide better carrots to lead the horses away from the rotting vegetables, which can be cleaned up later.
                            </p>
                            <h2>
                                finding harmony
                            </h2>
                            <p>
                                Some of what’s below is <a href="http://wiki.ecmascript.org/doku.php?id=harmony:proposals">already harmonious</a> according to TC39. Some is new, some is not yet proposed. The idea is to give an overview of Harmony that covers all of the high points and adds some new spice, instead of referring true believers to the sprawling <a href="http://wiki.ecmascript.org/doku.php?id=harmony:harmony">wiki</a> and then hoping they can figure things out from <a href="http://wiki.ecmascript.org/doku.php?do=recent&amp;id=">recent changes</a> and the <a href="https://mail.mozilla.org/listinfo/es-discuss/">discussion list</a>.
                            </p>
                            <p>
                                Unlike the CoffeeScript docs, I’ll show JS as it is implemented today on the left, and Harmony-of-my-dreams code on the right. This emphasizes how we’re working to fill gaps in the language’s semantics, not simply add sugar that lowers from new syntax to old. There’s nothing wrong with <a href="http://en.wikipedia.org/wiki/Desugaring">desugaring</a>, and I believe CoffeeScript and other front ends for JS have a bright future, but TC39 is charged with evolving the core language, especially in ways that can’t be done efficiently or at all in today’s JS.
                            </p>
                            <p>
                                With this context in mind, let’s dive in.
                            </p>
                            <h2>
                                binding and scope
                            </h2>
                            <p>
                                Block scoped <code>let</code> and <code>const</code>, not weird old hoisted (to top of function or script) <code>var</code>. Lexical scope all the way up, no global object on the scope chain. <a href="http://en.wikipedia.org/wiki/Free_variable">Free variables</a> are <a href="http://ecma262-5.com/ELS5_Section_16.htm">early errors</a>.
                            </p>
                            <pre>
var still_hoisted = "alas"
var PRETEND_CONST = 3.14
function later(f, t, type) {
  setTimeout(f, t, typo) // oops...
}
</pre>
                            <pre>
let block_scoped = "yay!"
const REALLY = "srsly"
function later(f, t, type) {
  setTimeout(f, t, typo) // EARLY ERROR
}
</pre>
                            <p>
                                Removing the global <code>window</code> object from the scope chain doesn’t mean it won’t be available, though; see <a href="http://brendaneich.com/#modules"></a>modules below.
                            </p>
                            <h2>
                                functions
                            </h2>
                            <p>
                                [Presented in the spirit of the <a href="http://www-archive.mozilla.org/apology.html">Mozilla Apologator</a>:] I’m sorry for picking so long a keyword. Beyond the length of <code>function</code>, and for all the many wins of closures, the objects that result from evaluating function declarations and expressions have some very shaggy hair. Time for a trim, starting with syntax proposed by <a href="http://twitter.com/#!/ErikArvidsson">@Arv</a> and <a href="http://infrequently.org/">@Alex</a>, extended to work with binding keywords:
                            </p>
                            <pre>
function add(a, b) { return a + b }
(function(x) { return x * x })
</pre>
                            <pre>
const #add(a, b) { a + b }
#(x) { x * x }
</pre>
                            <p>
                                The <code>#</code> character is one of few ASCII punctuators available. My straw polls on better characters to use has not led to a clear winner, and this one is proposed for Harmony. CoffeeScript’s <code>-&gt;</code> and <code>=&gt;</code> seem to require bottom-up parsing, so they’re not going to fly among implementors.
                            </p>
                            <p>
                                Beyond syntax, notice how the braced body can end in an expression statement that evaluates to the implicit return value. And here’s another difference from functions: <code>#</code>-functions are immutable and <a href="http://wiki.ecmascript.org/doku.php?id=strawman:const_functions#joining">joined</a>.
                            </p>
                            <p>
                                What to call these <code>#</code> functions? Ruby has given up <a href="http://blog.peepcode.com/tutorials/2011/rip-ruby-hash-rocket-syntax">hash rockets</a>. Can JS coin a new hash-phrase: hash-funcs? Suggestions welcome.
                            </p>
                            <p>
                                We should not call these things <a href="http://wiki.ecmascript.org/doku.php?id=strawman:lambdas">lambdas</a>, as that drags in untenable <a href="http://gafter.blogspot.com/2006/08/tennents-correspondence-principle-and.html">Tennent’s Correspondence Principle</a> strangeness, such as <code>return</code> from a lambda returning from its enclosing function (if still active; otherwise you would get a <a href="https://mail.mozilla.org/pipermail/es-discuss/2008-December/008390.html">runtime error</a>).
                            </p>
                            <h2>
                                tail position
                            </h2>
                            <p>
                                The implicit return value does more than save six characters plus one space (relieving you of having to type return ), it also makes the last expression statement be in <a href="http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls">tail position</a>. This contrasts with a JS function, which has an implicit <code>return undefined;</code> at the end of its body.
                            </p>
                            <pre>
function cps(x) { not_tail(x) }
function cps_harder(x) {
  work(x)
  return tail(x)
}
</pre>
                            <pre>

const #cps_smarter(x) {
  work(x)
  tail()
}
</pre>
                            <p>
                                At his <a href="http://jsconf.eu/2010/speaker/loopage_by_douglas_crockford.html">JSConf.eu talk</a> last fall, <a href="http://crockford.com/">@Crock</a> promoted the idea of <a href="http://wiki.ecmascript.org/doku.php?id=harmony:proper_tail_calls">proper tail calls</a>, something we have wrestled with in TC39 since ES4 days. Tail calls are a feature of Scheme, providing an asymptotic space guarantee (in plain English, you can tail-call without growing the call stack inevitably to entrain the space for all args and vars active along the dynamic call chain).
                            </p>
                            <p>
                                I agree with Doug that tail calls would be a win, especially with <a href="http://nodejs.org/">evented code</a>. The <code>#</code> function syntax allows us to give tail calls a boost and save you seven (14 total: <code>function</code> + <code>return_</code> - <code>#</code>) keystrokes.
                            </p>
                            <p>
                                Some have objected that this creates an unintended <a href="https://mail.mozilla.org/pipermail/es5-discuss/2009-June/002822.html">completion value</a> leak-hazard, but (a) we can improve the Harmony definition of completion value in <code>#</code>-functions, (b) the <code>void</code> operator I added <a href="http://www.quora.com/Why-do-most-web-browsers-allow-the-execution-of-JavaScript-code-from-the-address-bar">for <code>javascript:</code> URLs</a> back in '95 stands ready, and (c) when in doubt, use <code>function</code> syntax or write an explicit <code>return</code>.
                            </p>
                            <h2>
                                no arguments
                            </h2>
                            <p>
                                The <code>arguments</code> object is another <a href="http://www.aminutewithbrendan.com/pages/20101115">clump of hair</a> to trim from functions in adding hash-funcs. With Harmony, we have <a href="http://brendaneich.com/#rest_parameters">rest parameters</a>, so we don't need no steenking <code>arguments</code>!
                            </p>
                            <pre>
(function () {
  return typeof arguments
})() == "undefined"
</pre>
                            <pre>
#() {
  typeof arguments
}() == "undefined"
</pre>
                            <p>
                                This haircut makes life simpler for web developers; it means even more to JS implementors.
                            </p>
                            <h2>
                                lexical this
                            </h2>
                            <p>
                                Another Tennent's Correspondence Principle casualty: <code>this</code> default binding. When you call <code>o.m()</code> in JS, unless <code>m</code> is a <a href="http://whereswalden.com/2010/09/07/now-in-spidermonkey-and-firefox-es5s-function-prototype-bind/">bound method</a>, <code>this</code> must bind to <code>o</code>. But for all functions in <a href="http://kangax.github.com/es5-compat-table/">ES5 strict mode</a>, and therefore in Harmony (based on ES5 strict), <code>this</code> is bound to <code>undefined</code> when the function is called by its lexical name (<code>f</code>, not <code>o.m</code> for <code>o.m=f</code>).
                            </p>
                            <p>
                                Binding <code>this</code> to <code>undefined</code> censors the global object, a <a href="http://www.eecs.berkeley.edu/~jww/papers/2009/barth-weinberger-song.pdf">capability leak</a>. Apart from that fix, though, passing <code>undefined</code> as <code>this</code> is nearly useless.
                            </p>
                            <p>
                                Why not bind <code>this</code> to the same value as in the code enclosing the hash-func? Doing so will greatly reduce the need for <code>var self=this</code> or <code>Function.prototype.bind</code>, especially with the <a href="https://developer.mozilla.org/en/new_in_javascript_1.6#Array_extras">Array extras</a>.
                            </p>
                            <pre>
function writeNodes() {
  var self = this
  this.nodes.forEach(function(node) {
    self.write(node);
  }
}
</pre>
                            <pre>
function writeNodes() {

  this.nodes.forEach(#(node) {
    this.write(node);
  }
}
</pre>
                            <p>
                                It's great that ES5 added <code>bind</code> as a standard method, but why should you have to call it all over the place? If Harmony does not address this issue, I will count that a failure.
                            </p>
                            <h2>
                                records
                            </h2>
                            <p>
                                A hot-button issue with ES5: <code>Object.freeze</code>. Whose side are you on, Batman's or Mr. Freeze's? Simplistic to say the least, since even in one's own small-world codebase, making some things immutable protects against mistakes. Never mind single- and multi-threaded data sharing and other upside.
                            </p>
                            <p>
                                However, calling an <code>Object</code> method around every object initialiser you want frozen is a drag, and even then, the JS engine has to stand on its head and spin around to figure out that all the many evaluations of such an expression could be shared (but for the violation of object identity, detectable via <code>===</code> and <code>!==</code>, that sharing would create; but that could be optimized too, at some further expense).
                            </p>
                            <p>
                                With <code>#</code> we can do better:
                            </p>
                            <pre>
var point = {x: 10, y: 20}
point.equals({x: 10, y: 20})
</pre>
                            <pre>
const point = #{x: 10, y: 20}
point === #{x: 10, y: 20}
</pre>
                            <p>
                                Not only does the <code>#</code> <a href="http://en.wikipedia.org/wiki/Sigil_%28computer_programming%29">sigil</a> allow us to create records that are <a href="http://en.wikipedia.org/wiki/Hash_cons">hash-cons</a>'ed so there is only one object identity per nearest containing relevant closure; we also get <code>==</code> and <code>!=</code> (and the triple-equals forms) for free. Object content-based equality.
                            </p>
                            <h2>
                                tuples
                            </h2>
                            <p>
                                You may have noticed a trend here. Gaps in the JS language in usability, semantic unity of purpose, and reliability or invariance, can be made up for by adding "hash forms" that are shorter or still short enough, better for optimization, and free from mutation hazards and other historic hair. The same goes for <code>Arrays</code>, via <a href="http://en.wikipedia.org/wiki/Tuple">tuples</a>:
                            </p>
                            <pre>
var tuple = [1, 2, 3]
tuple[tuple.length-1] === 3
Array.prototype.compare = /*...*/
tuple.slice(0, 2).compare([1, 2]) == 0
tuple.compare([1, 2, 4]) &lt; 0
</pre>
                            <pre>
const tuple = #[1, 2, 3]
tuple[-1] === 3

tuple[0:2] === #[1, 2]
tuple &lt; #[1, 2, 4]
</pre>
                            <p>
                                Not only are the equality operators (strict and loose) based on contents and not object identity (which is not material due to the implicit freezing of these array-like objects), tuples support relational operators (<code>&lt; &lt;= &gt; &gt;=</code>), again based on contents not identity.
                            </p>
                            <p>
                                Relationals could work on records too, using <a href="http://wiki.ecmascript.org/doku.php?id=strawman:enumeration">enumeration order</a> (assuming we standardize that order sanely).
                            </p>
                            <p>
                                Negative indexing, something <a href="https://mail.mozilla.org/pipermail/es-discuss/2010-November/012126.html">unlikely</a> to be grafted onto <code>Array</code> in Harmony (see "shared-object-heap interoperation" point above), is more than a minor convenience in my book. It's also something Harmony <code>Proxy</code> handlers can implement. So tuples should support negative indexing even if arrays do not. And it ought to be cheap to create a tuple from an <code>Array</code> instance.
                            </p>
                            <p>
                                If negative indexing works, can slices and ranges be far behind? I'll leave those for another post.
                            </p>
                            <p>
                                <code>Array.prototype</code> is full of generic methods, most of which do not mutate <code>this</code>. It's tempting to want tuples to delegate to <code>Array.prototype</code>, with optimizations possible (as fast engines do today for dense-enough arrays). I'll throw this idea out and confess I haven't thought through every corner of it.
                            </p>
                            <p>
                                One known bug in the <code>Array.prototype</code> methods that construct a new array object, e.g. <code>slice</code>: they always make an <code>Array</code> instance, instead of calling <code>new this.constructor</code>. I agree with <a href="http://infrequently.org/">@Alex</a> that we ought to fix this bug in Harmony.
                            </p>
                            <h2>
                                statements
                            </h2>
                            <p>
                                Here I recap <a href="http://brendaneich.com/2010/11/paren-free/">paren-free</a>, which I have prototyped in <a href="https://github.com/mozilla/narcissus/">Narcissus</a> (invoked via <code>njs --paren-free</code>), but with an obvious and convenient extension:
                            </p>
                            <pre>
if (x &gt; y) alert("brace-free")
if (x &gt; z) return "paren-full"
if (x &gt; y) f() else if (x &gt; z) g()
</pre>
                            <pre>
if x &gt; y { alert("paren-free") }
if x &gt; z return "brace-free"
if x &gt; y { f() } else if x &gt; z { g() }
</pre>
                            <p>
                                We do not want <code>else</code> clauses to be braced no matter what. In particular, an <code>if</code> statement as the <code>else</code> clause should not be braced, to avoid rightward indentation drift. Therefore any statement that starts with a keyword need not be braced. This is a boon for short <code>break</code>, <code>continue</code>, <code>return</code>, and <code>throw</code> statements often controlled by <code>if</code> heads that guard uncommon conditions.
                            </p>
                            <h2>
                                <a name="modules" id="modules">modules</a>
                            </h2>
                            <p>
                                The <a href="http://wiki.ecmascript.org/doku.php?id=strawman:simple_modules">simple modules</a> proposal, along with its <a href="http://wiki.ecmascript.org/doku.php?id=strawman:module_loaders">module loaders</a> adjunct, is the likely Harmony module system solution. Note that there is no left-hand side example written in current JS below -- you'd need a preprocessor, not part of the language.
                            </p>
                            <pre>





</pre>
                            <pre>
module M {
  module N = "http://N.com/N.js"
  export const K = N.K
  export #add(x, y) { x + y }
}
</pre>
                            <p>
                                Modules are being prototyped in <a href="https://github.com/mozilla/narcissus/">Narcissus</a> by <a href="http://blog.mozilla.com/dherman/">@little_calculist</a> right now. More on this at the end.
                            </p>
                            <h2>
                                iteration
                            </h2>
                            <p>
                                The impetus for <a href="http://brendaneich.com/2010/11/paren-free/">paren-free</a> was the poor old <code>for-in</code> loop. I propose we break it utterly by requiring an unparenthesized head sporting implicit <code>let</code> binding, and the "always use the one true iteration protocol" semantics. Also, generators based on JS1.7, based on Python. All of this is pretty much as in Python, but built on proxies.
                            </p>
                            <pre>


for (var k in o) append(o[k])






</pre>
                            <pre>
module Iter = "@std:Iteration"
import Iter.{keys,values,items,range}
for k in keys(o) { append(o[k]) }
for v in values(o) { append(v) }
for [k,v] in items(o) { append(k, v) }
for x in o { append(x) }
#sqgen(n) { for i in range(n) yield i*i }
return [i * i for i in range(n)]
return (i * i for i in range(n))
</pre>
                            <p>
                                Migrating <code>for-in</code> loops into Harmony will require saying what you mean.
                            </p>
                            <p>
                                That <code>"@std:Iteration"</code>module resource locator is something I made up. It's an "anti-URL" since it starts with <code>@</code>. The idea is to be able to name built-in modules without having to write URLs, and without colliding with any possible URL. You could imagine <code>"@dom"</code> too.
                            </p>
                            <h2>
                                <a name="rest_parameters" id="rest_parameters">rest parameters</a>
                            </h2>
                            <p>
                                Instead of the bad-smelling <code>arguments</code> object, Harmony boasts <a href="http://wiki.ecmascript.org/doku.php?id=harmony:parameter_default_values">parameter default values</a> (not shown here) and <a href="http://wiki.ecmascript.org/doku.php?id=harmony:rest_parameters">rest parameters</a>.
                            </p>
                            <pre>
function printf(format) {
  var args = Array.prototype.slice
                  .call(arguments,1)

  /* use args as a real array here */
}
</pre>
                            <pre>
function printf(format, ...args) {
  /* use args as a real array here */
}



</pre>
                            <p>
                                With hash-funcs, default parameter values and rest parameters are all you get -- no more <code>arguments</code>.
                            </p>
                            <p>
                                Should tuples become harmonious, the question arises: how does a rest parameter reflect, as an array or as a tuple? The answer may depend on how important it is to <code>splice</code>, <code>reverse</code>, or <code>sort</code> a rest parameter. VM implementors would love the frozen tuple answer. Most JS hackers who cared would, I suspect, favor array over tuple here.
                            </p>
                            <h2>
                                spread
                            </h2>
                            <p>
                                A companion to rest parameters, the spread syntax allows one to expand an array's elements as positional parameters or <a href="http://bclary.com/2004/11/07/#a-11.1.4">array initialiser</a> elements. Finally you can write a generic constructor-invoking helper without using <code>switch</code> and <code>eval</code>:
                            </p>
                            <pre>
function construct(f, a) {
  switch (a.length) {
    case 0: return new f
    case 1: return new f(a[0])
    case 2: return new f(a[0], a[1])
    default:
      var s = "new f("
      for (var i = 0; i &lt; a.length; i++)
       s += "a[" + i + "],"
     s = s.slice(0, -1) + ")"
     return eval(s)
  }
}
</pre>
                            <pre>
function construct(f, a) {
  return new f(...a)
}










</pre>
                            <p>
                                Even without the 0, 1, and 2 special cases, this significant savings in lines screams "semantic gap being filled!"
                            </p>
                            <p>
                                UPDATE: <a href="http://erights.org/">@markm</a> emailed to remind me that ES5 fills the gap part-way, at the price of a bound function:
                            </p>
                            <pre>
function construct(f, a) {
  var ctor = Function.prototype.bind
             .apply(f, [null].concat(a))
  return new ctor();
}
</pre>
                            <pre>
function construct(f, a) {
  return new f(...a)
}


</pre>
                            <p>
                                ES5 helps, but I think it is time to prototype Harmony's <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=574130">spread</a> for Firefox.next.
                            </p>
                            <h2>
                                destructuring
                            </h2>
                            <p>
                                Often in JS you'll find yourself unpacking the properties of an object into same-named variables. Destructuring binding and assignment (prototyped since 2006 in JS1.7 in Firefox) fill this gap:
                            </p>
                            <pre>
var first = sequence[0],
    second = sequence[1]
var name = person.name,
    address = person.address
    // no easy misc solution

</pre>
                            <pre>
let [first, second] = sequence

const {name, address, ...misc} = person


</pre>
                            <p>
                                The destructuring patterns mimic object and array initialisers, and raise the possibility of <a href="http://www.haskell.org/tutorial/patterns.html">refutable matching</a> in JS.
                            </p>
                            <h2>
                                library missing links
                            </h2>
                            <p>
                                <a href="http://wiki.ecmascript.org/doku.php?id=strawman:array_create"><code>Array.create</code></a>, <a href="http://wiki.ecmascript.org/doku.php?id=strawman:name_property_of_functions"><code>Function.create</code></a> (like <code>Function</code> but with a leading <code>name</code> parameter), <a href="http://wiki.ecmascript.org/doku.php?id=strawman:binary_data">binary data</a>, <a href="http://brendaneich.com/2010/11/proxy-inception/">proxies</a>, and <a href="http://wiki.ecmascript.org/doku.php?id=harmony:weak_maps">weak maps</a>.
                            </p>
                            <pre style="width:610px">
Array.create(proto, [1, 2, 3]) // see also Array.createConstructor

Function.create(name, ...params, body);

const Point2D = new StructType({ x: uint32, y: uint32 });
const Color = new StructType({ r: uint8, g: uint8, b: uint8 });
const Pixel = new StructType({ point: Point2D, color: Color });
const Triangle = new ArrayType(Pixel, 3);

Proxy.create(handler, proto)
Proxy.createFunction(handler, call, construct)

const map = WeakMap()
map.set(obj, value)
</pre>
                            <p>
                                These are just the big dogs in the Harmony standard library kennel, but worth some attention.
                            </p>
                            <p>
                                In particular, proxies really want weak maps. Weak maps are something JS has needed for ages in general. Have you ever kept objects in an array and searched by object identity, or else mutated objects to assign hashcodes to them? No more.
                            </p>
                            <p>
                                Binary data looks insanely useful, and we hope it will supplant WebGL typed arrays in due course.
                            </p>
                            <h2>
                                closing
                            </h2>
                            <p>
                                This is a long post. If you made it this far and take away anything, I hope it is Guy's "Growing a Language" meta-point. JS will be around for a very long time, and it has a chance to evolve until its users can replace TC39 as stewards of its growth. The promised land would be <a href="http://www.cs.indiana.edu/~dyb/pubs/LaSC-5-4-pp295-326.pdf">macros</a>, for syntactic abstraction and extensibility. I am not holding my breath, but even without macros, the Harmony-of-my-dreams sketched here would be enough for me.
                            </p>
                            <p>
                                We aim to do more than dream. <a href="https://github.com/mozilla/narcissus/">Narcissus</a> is coming along nicely since it moved to github and got a shot in the arm from our excellent Mozilla Research interns last summer. We are prototyping Harmony in Narcissus (invoked via <code>njs -H</code>), so you can run it as an alternate &lt;script&gt; engine via the <a href="https://mozillalabs.com/zaphod/">Zaphod</a> Firefox add-on.
                            </p>
                            <p>
                                <a href="http://andreasgal.wordpress.com/">@andreasgal</a> has a JS code generator for Narcissus in the works, which promises huge speedups compared to the old metacircular interpreter I wrote for fun in 2004. With good performance, we can actually do some usability studies of Harmony proposals, and avoid Harmony-of-our-nightmares: untested, hard-to-use committee designs.
                            </p>
                            <p>
                                A code-generating Narcissus has other advantages than performance. Migrating code into Harmony, what with the removal of the global object as top scope (never mind the other changes I'm proposing -- here's another one: <a href="http://wiki.ecmascript.org/doku.php?id=strawman:object_isobject">let's fix typeof</a>), needs automated checking and even code rewriting. <a href="http://doctorjs.org/">DoctorJS</a> uses a static analysis built on top of Narcissus, which could be used to find flaws, not just migration changes. Self-hosted parsing, JS-to-JS code generation, and <a href="http://brendaneich.com/2010/08/static-analysis-ftw/">powerful static analysis</a> come together to make a pretty handy Harmonizer tool. So we're going to build that, too.
                            </p>
                            <p>
                                More on Narcissus and Zaphod as they develop. When the time is right, we will need users -- lots of them. As always, your comments are welcome.
                            </p>
                            <p>
                                /be
                            </p>
                        </blockquote>
                    </div>
                    <p class="bookmark-source">
                        Source: <a href="http://brendaneich.com/2011/01/harmony-of-my-dreams/">http://brendaneich.com/2011/01/harmony-of-my-dreams/</a>
                    </p>
                </div>
            </article>

            <nav id="post-nav">


            </nav>

            <script id="discus-javascript">
                var disqus_shortname = 'improbable';

                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
                    document.getElementsByTagName('body')[0].appendChild(dsq);
                })();
            </script>

            <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            <div id="disqus_thread"></div>
        </section>

        <footer id="site-footer" class="nocontent">
            <p>
                This site is purely my personal work and does not reflect the views of my employer.
            </p>
            <p class="license">
                <a class="icon" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png"></a>
                This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
            </p>
        </footer>

        <script async src="/static/js/common.js"></script>
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" integrity="sha256-hj+5FRlAuvAFANiefn0PpJYCkV1X4QT9EgiPd+6QnCw=" crossorigin="anonymous"></script>
    </body>
</html>
