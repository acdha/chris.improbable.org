<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>What is “simplicity” in programming?, redux</title>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="/static/css/main.min.css" type="text/css" media="all">
        <!--[if lte IE 8]>
            <link
                rel="stylesheet"
                href="/static/css/ie-fixes.css"
                type="text/css"
                media="all"
            />
            <script src="/static/js/html5shiv.js"></script>
        <![endif]-->

        <meta http-equiv="last-modified" content="Sun, 28 Mar 2010 14:30:29 GMT">
        <link rel="alternate" type="application/atom+xml" title="All Posts (Atom)" href="/feeds/all.atom">
        <link rel="alternate" type="application/rss+xml" title="All Posts (RSS)" href="/feeds/all.rss">
        <link rel="icon" type="image/jpeg" sizes="287x287" href="/static/img/favicon-287x287.jpg">
        <link rel="icon" type="image/jpeg" sizes="128x128" href="/static/img/favicon-128x128.jpg">
    </head>
    <body class="blog post_detail" itemscope itemtype="http://schema.org/BlogPosting">
        <nav id="site-nav">
            <header id="about">
                <h1><a href="/about/">Chris Adams</a></h1>
                <h2>Programmer, cyclist, photographer</h2>
            </header>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/feeds/all.atom" title="Site Feed">Site Feed</a>
                </li>
            </ul>
            <ul class="social-networks">
                <li>
                    <a rel="me" href="https://code4lib.social/@acdha">Mastodon</a>
                </li>
                <li>
                    <a href="https://github.com/acdha" rel="me">Github</a>
                </li>
                <li>
                    <a href="https://bitbucket.org/acdha" rel="me">Bitbucket</a>
                </li>
                <li>
                    <a href="https://pinboard.in/u:acdha/" rel="me">Pinboard</a>
                </li>
                <li>
                    <a href="https://www.flickr.com/photos/acdha" rel="me">Flickr</a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/in/acdha" rel="me">LinkedIn</a>
                </li>
            </ul>
            <div id="site-search"></div>
        </nav>
        <section id="main">
            <article class="post">
                <header>
                    <meta itemprop="dateCreated" content="2010-03-28T10:30:29-04:00">
                    <meta itemprop="dateModified" content="2010-03-28T10:30:29-04:00">
                    <time class="date" itemprop="datePublished" datetime="2010-03-28T14:30:29+00:00">Mar 28</time>
                    <h2 class="" itemprop="title">What is “simplicity” in programming?, redux</h2>
                </header>

                <div class="body" itemprop="articleBody"><div class="googlereader description" data-google-id="tag:google.com,2005:reader/item/81f18b717740ee11">
                        <blockquote>
                            <div>
                                <p>
                                    This is an immediate followup, about twelve hours after I posted the original <a href="http://reprog.wordpress.com/2010/03/28/what-is-simplicity-in-programming/">What is “simplicity” in programming?﻿</a>, because the ﻿excellent comments on that post have pointed me to another insight.  In particular, <a href="http://reprog.wordpress.com/2010/03/28/what-is-simplicity-in-programming/#comment-863">Chris pointed out</a> that “﻿Ideally, you would not have to read the code of all the methods as the name should tell you by himself what is it doing.”
                                </p>
                                <p>
                                    I think Chris has put his finger on an area where individual temperament, preference and aptitude is very important.  Probably, skipping over the small methods <em>is</em> the right thing for at least some programs — the ones that have been extensively Fowlered.  But it doesn’t come naturally to me at all.  It makes me nervous.  I actually feel physically uncomfortable about working with code that I’ve not read.  So maybe that’s why I am happier with one larger method than several smaller ones sprinkled across various classes and files.  (To be clear, I am not advocating big functions and classes — no-one wants to read 300 lines in a single method, or classes with 50 methods.  I’m in favour of biggER functions and classes than Martin Fowler is, that’s all.)
                                </p>
                                <p>
                                    <a href="http://reprog.files.wordpress.com/2010/03/dsc_3253_550.jpg"><img title="dsc_3253_550" src="http://reprog.files.wordpress.com/2010/03/dsc_3253_550.jpg?w=300&amp;h=201" alt="" width="300" height="201"></a>
                                </p>
                                <p>
                                    As I said back in <a href="http://reprog.wordpress.com/2010/03/02/learning-a-language-vs-learning-a-culture/">Learning a language vs. learning a culture</a>, I find that the best way for me to learn a new technology (be it a programming language, an MVC framework or whatever) is to get an actual honest-to-goodness old-fashioned book, and read it right through.  I don’t feel good about that, because I have a mental model where True Hackers just plough straight in and learn as they go along, but when I’ve tried that approach I never feel fully master of the situation.  (That’s how I feel about CSS, for example: I can do it, but I am not confident that I understand <em>what</em> I am doing, or <em>why</em> it works: I always have to experiment a bit before I get the right combination of margin, border and padding, because I’ve yet to sit down and properly learn the box model.)
                                </p>
                                <p>
                                    And regular readers will remember that I remember fondly <a href="http://reprog.wordpress.com/2010/03/12/programming-books-part-3-programming-the-commodore-64/">the days when we could know everything there was to know about our Commodore 64s</a>.   I think that may be another manifestation of the same character trait: I want to know things <em>deeply</em>; in fact, I <em>need</em> to know things deeply before I can be properly productive.  (That’s why I’ve been learning Rails for several weeks already, but have yet to write any Rails code of my own beyond working through all the Depot examples in the book.)
                                </p>
                                <p>
                                    Now that I’ve spotted this pattern in my behaviour, I can see it at work in other ways: for example, it’s very, very unusual that, having started to read a novel, I don’t finish it.  (The last such was Mervyn Peake’s <em>Titus Groan</em>, which a lot of people love, but which, so far as I can tell, doesn’t seem to have any actual story.)  And when I become interested in the music of someone I’m not already familiar with, I like to buy a single well-regarded album by that artist and listen to it heavily, rather than getting a Greatest Hits compilation, or listening to random tracks on Grooveshark.
                                </p>
                                <p>
                                    So since I like to learn computer architectures and MVC frameworks depth-first, and since I read novels depth-first and listen to music depth-first, I suppose it’s not surprising that I like to read code depth-first — and that, therefore, extensively Fowlered code, with its long chains of responsibility, its delegates-of-delegates-of-delegates and its light sprinkling of tiny classes, doesn’t suit me.
                                </p>
                                <p>
                                    (Again, understand: I am not saying that Fowler is <em>wrong</em>; just that what works for him doesn’t work for me.)
                                </p>
                                <p>
                                    <a href="http://reprog.files.wordpress.com/2010/03/3d54177967dea5760ff273a80a922bb246117162_375.jpg"><img title="3d54177967dea5760ff273a80a922bb246117162_375" src="http://reprog.files.wordpress.com/2010/03/3d54177967dea5760ff273a80a922bb246117162_375.jpg?w=300&amp;h=224" alt="" width="300" height="224"></a>
                                </p>
                                <p>
                                    It’s easy to see that breadth-first code-reading is related to top-down programming, and depth-first to bottom-up programming.  Depth-first/bottom-up is all about understanding the details, and letting the high-level picture emerge from them; Breadth-first/top-down is about grasping the overall shape of the system, and letting the details look after themselves (or at least, coming back to them later).  Despite <a href="http://reprog.wordpress.com/2010/03/09/where-dijkstra-went-wrong-the-value-of-basic-as-a-first-programming-language/">the efforts of Dijkstra and others</a> to impose top-down as The One True Way to write programs, it’s been accepted for many years now that both top-down and bottom-up (and other variants) can work well, and also that different individuals excel in different directions.  So maybe it’s no surprise that the same seems to be true of depth-first vs. breadth-first.
                                </p>
                                <p>
                                    I truly don’t know whether it’s better, overall, to have a depth-first or a breadth-first mind.  Now that I’ve at least realised that there is this distinction, and now that I’ve seen which side of the dichotomy I fall on, I can and will take deliberate steps to improve my use of breadth-first approaches when that’s the appropriate strategy — for example, when reading the code of a high-level class in a Fowlered program.  Hopefully I can do that without converting completely to the dark^H^H^H^Hother side — I want to retain the ability to go depth-first when Deep Knowing is what’s required.
                                </p>
                                <p>
                                    Of course, this also means I am going to need to develop judgement to know when which approach is optimal.  One candidate rule might be: breadth-first code-reading is better when there are strong naming conventions that tell you with reasonably confidence what the lower levels do.  (This brings us right back to Chris’s comment that kicked off this post.)  If that rule is correct, then it implies I’m going to have to do something I’ve been carefully avoiding for many years: read the Gang Of Four <em>Design Patterns</em> book, if only so that I can instantly recognise and interpret class- and method-names based on their patterns’ names. <em>*sigh*</em>
                                </p>
                                <p>
                                    I’d be interested to hear proposals of other rules that we could usefully use to determine when to take a depth-first or breadth-first approach to learning something, be it a codebase, a technology or something completely different.  Let’s hear them in the comments — I want to learn!
                                </p>
                                <div style="width:210px">
                                    <a href="http://reprog.files.wordpress.com/2010/03/3870418362_a51bf18af0_o.jpg"><img title="3870418362_a51bf18af0_o" src="http://reprog.files.wordpress.com/2010/03/3870418362_a51bf18af0_o.jpg?w=200&amp;h=300" alt="" width="200" height="300"></a>
                                    <p>
                                        Click through this one -- the big version is sensational.
                                    </p>
                                </div>
                                <p>
                                    Finally, in defence of Fowler: in another comment on the last article, Martin Probst <a href="http://reprog.wordpress.com/2010/03/28/what-is-simplicity-in-programming/#comment-869">made the important point</a> that “﻿the problem with books like this and their examples is that the technique is geared at e.g. a hideously complex loan system, but to keep the examples understandable they must be so short that it kind of defeats the point.”  That is very true: all writing about programming suffers from the limitations of small examples, but it’s particularly damaging in discussion of techniques like Fowler’s which are largely directed and keeping software comprehensible as a system grows.
                                </p>
                                <h2>
                                    Update (a few hours later)
                                </h2>
                                <p>
                                    It only occurred to me after having posted this that there is another excellent example that illustrates me depth-first approach: the way I play <em>Quake</em>.  (Although <em>Quake</em> is old, I still like it more than any of its better-looking successors because it feels so solid and chunky, and because there is such a lively community producing excellent free maps for it.)
                                </p>
                                <p>
                                    <a href="http://reprog.files.wordpress.com/2010/03/gmsp31.jpg"><img title="gmsp31" src="http://reprog.files.wordpress.com/2010/03/gmsp31.jpg?w=280&amp;h=210" alt="" width="280" height="210"></a>
                                </p>
                                <p>
                                    When I play <em>Quake</em>, I go slowly and carefully, peeking around corners, trying to pick off monsters one by one as far as possible rather than ploughing in with all guns blazing.  I like to play on Nightmare, and to carefully explore every tiny dead-end of the map.  I don’t consider a level properly beaten until I have 100% kills (although 100% secrets is not always realistic).  When my sons watch me playing <em>Quake</em>, they find it frustrating that I go so slowly: they’re always shouting at me to “push the button” whenever I find one.  But I don’t want to push the button until I’ve finished surveying the available ground, so that when I <em>do</em> push it, I can tell what’s changed.  Only then will I push the button, find the new door, and go on to the next part of the level.
                                </p>
                                <p>
                                    Yes, I am playing depth-first <em>Quake</em>.  I want to understand the level deeply.  Not coincidentally, I tend to finish levels much more slowly than most players.  But then I die less often.
                                </p>
                            </div>
                        </blockquote>
                    </div>
                    <p class="bookmark-source">
                        Source: <a href="http://reprog.wordpress.com/2010/03/28/what-is-simplicity-in-programming-redux">http://reprog.wordpress.com/2010/03/28/what-is-simplicity-in-programming-redux</a>
                    </p>
                </div>
            </article>

            <nav id="post-nav">


            </nav>
        </section>

        <footer id="site-footer" class="nocontent">
            <p>
                This site is purely my personal work and does not reflect the
                views of my employer.
            </p>
            <p class="license">
                <a class="icon" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png"></a>
                This work is licensed under a
                <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported
                    License</a>.
            </p>
        </footer>

        <script async src="/static/js/common.js"></script>
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" integrity="sha256-hj+5FRlAuvAFANiefn0PpJYCkV1X4QT9EgiPd+6QnCw=" crossorigin="anonymous"></script>
    </body>
</html>
