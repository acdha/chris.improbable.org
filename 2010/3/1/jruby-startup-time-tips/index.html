<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>JRuby Startup Time Tips</title>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="/static/css/main.min.css" type="text/css" media="all">
        <!--[if lte IE 8]>
            <link
                rel="stylesheet"
                href="/static/css/ie-fixes.css"
                type="text/css"
                media="all"
            />
            <script src="/static/js/html5shiv.js"></script>
        <![endif]-->

        <meta http-equiv="last-modified" content="Mon, 01 Mar 2010 23:09:54 GMT">
        <link rel="alternate" type="application/atom+xml" title="All Posts (Atom)" href="/feeds/all.atom">
        <link rel="alternate" type="application/rss+xml" title="All Posts (RSS)" href="/feeds/all.rss">
        <link rel="icon" type="image/jpeg" sizes="287x287" href="/static/img/favicon-287x287.jpg">
        <link rel="icon" type="image/jpeg" sizes="128x128" href="/static/img/favicon-128x128.jpg">
    </head>
    <body class="blog post_detail" itemscope itemtype="http://schema.org/BlogPosting">
        <nav id="site-nav">
            <header id="about">
                <h1><a href="/about/">Chris Adams</a></h1>
                <h2>Programmer, cyclist, photographer</h2>
            </header>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/feeds/all.atom" title="Site Feed">Site Feed</a>
                </li>
            </ul>
            <ul class="social-networks">
                <li>
                    <a rel="me" href="https://code4lib.social/@acdha">Mastodon</a>
                </li>
                <li>
                    <a href="https://github.com/acdha" rel="me">Github</a>
                </li>
                <li>
                    <a href="https://bitbucket.org/acdha" rel="me">Bitbucket</a>
                </li>
                <li>
                    <a href="https://pinboard.in/u:acdha/" rel="me">Pinboard</a>
                </li>
                <li>
                    <a href="https://www.flickr.com/photos/acdha" rel="me">Flickr</a>
                </li>
                <li>
                    <a href="https://www.linkedin.com/in/acdha" rel="me">LinkedIn</a>
                </li>
            </ul>
            <div id="site-search"></div>
        </nav>
        <section id="main">
            <article class="post">
                <header>
                    <meta itemprop="dateCreated" content="2010-03-01T16:52:00-04:00">
                    <meta itemprop="dateModified" content="2010-03-01T16:52:00-04:00">
                    <time class="date" itemprop="datePublished" datetime="2010-03-01T20:52:00+00:00">Mar 01</time>
                    <h2 class="" itemprop="title">JRuby Startup Time Tips</h2>
                </header>

                <div class="body" itemprop="articleBody"><div class="googlereader description" data-google-id="tag:google.com,2005:reader/item/5c3cf5a8026a116f">
                        <blockquote>
                            JRuby has become notorious among Ruby implementations for having a slow startup time. Some of this is the JVM's fault, since it doesn't save JIT products and often just takes a long time to boot and get going. Some of this is JRuby's fault, though we work very hard to eliminate startup bottlenecks once they're reported and diagnosed. But a large number of startup time problems stem from simple configuration issues. Here's a few tips to help you improve JRuby's startup time.
                            <div>
                                <br>
                            </div>
                            <div>
                                (Note: JRuby actually does pretty well on base startup time compared to other JVM languages; but MRI, while generally not the fastest Ruby impl, starts up incredibly fast.)
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Make sure you're running the client JVM</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                This is by far the easiest way to improve startup. On HotSpot, the JVM behind OpenJDK and Sun's JDK, there are two different JIT-compiling backends: "client" and "server". The "client" backend does only superficial optimizations to JVM code as it compiles, but compiles things earlier and more quickly. The "server" backend performs larger-scale, more-global optimizations as it compiles, but takes a lot longer to get there and uses more resources when it compiles.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                Up until recently, most JVM installs preferred the "client" backend, which meant JVM startup was about as fast as it could get. Unfortunately, many newer JVM releases on many operating systems are either defaulting to "server" or defaulting to a 64-bit JVM (which only has "server"). This means that without you or JRuby doing anything wrong, startup time takes a major hit.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                Here's an example session showing a typical jruby -v line for a "server" JVM and the speed of doing some RubyGems requires (which is where most time is spent booting a RubyGems-heavy application):
                            </div>
                            <pre>
~/projects/jruby ➔ jruby -v<br>jruby 1.5.0.dev (ruby 1.8.7 patchlevel 174) (2010-03-01 6857a4e) (Java HotSpot(TM) 64-Bit Server VM 1.6.0_17) [x86_64-java]<br><br>~/projects/jruby ➔ time jruby -e "require 'rubygems'; require 'active_support'"<br><br>real 0m5.174s<br>user 0m7.643s<br>sys 0m0.422s<br><br>~/projects/jruby ➔ time jruby -e "require 'rubygems'; require 'active_support'"<br><br>real 0m5.068s<br>user 0m7.662s<br>sys 0m0.449s
</pre>
                            <div>
                                Ouch, over 5 seconds just to boot RubyGems and load ActiveSupport. You can see in this case that the JVM is preferring the "64-Bit Server VM", which will give you great runtime performance but pretty dismal startup time. If you see this sort of -v output, you can usually force the JVM to run in 32-bit "client" mode by specifying "-d32" as a JVM option. Here's an example using an environment variable:
                            </div>
                            <pre>
~/projects/jruby ➔ export JAVA_OPTS="-d32"<br><br>~/projects/jruby ➔ time jruby -e "require 'rubygems'; require 'active_support'"<br><br>real 0m2.320s<br>user 0m2.583s<br>sys 0m0.207s<br><br>~/projects/jruby ➔ time jruby -e "require 'rubygems'; require 'active_support'"<br><br>real 0m2.275s<br>user 0m2.580s<br>sys 0m0.207s
</pre>
                            <div>
                                On my system, a MacBook Pro running OS X 10.6, switching to the "client" VM improves this scenario by well over 50%. You may also want to try the "-client" option alone or in combination with -d32, since some 32-bit systems will still default to "server". Play around with it and see what works for you, and then let us know your platform, -v string, and how much improvement you see.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Regenerate the JVM's shared archive</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                Starting with Java 5, the HotSpot JVM has included a feature known as <a href="http://java.sun.com/j2se/1.5.0/docs/guide/vm/class-data-sharing.html">Class Data Sharing (CDS)</a>. Originally created by Apple for their OS X version of HotSpot, this feature loads all the common JDK classes as a single archive into a shared memory location. Subsequent JVM startups then simply reuse this read-only shared memory rather than reloading the same data again. It's a large reason why startup times on Windows and OS X have been so much better in recent years, and users of those systems may be able to ignore this tip.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                On Linux, however, the shared archive is often *never* generated, since installers mostly just unpack the JVM into its final location and never run it. In order to force your system to generate the shared archive, run some equivalent of this command line:
                            </div>
                            <pre>
headius@headius-desktop:~/jruby$ sudo java -Xshare:dump<br>Loading classes to share ... done.<br>Rewriting and unlinking classes ... done.<br>Calculating hash values for String objects .. done.<br>Calculating fingerprints ... done.<br>Removing unshareable information ... done.<br>Moving pre-ordered read-only objects to shared space at 0x94030000 ... done.<br>Moving read-only objects to shared space at 0x9444bef8 ... done.<br>Moving common symbols to shared space at 0x9444d870 ... done.<br>Moving remaining symbols to shared space at 0x945154e0 ... done.<br>Moving string char arrays to shared space at 0x94516118 ... done.<br>Moving additional symbols to shared space at 0x945ac5b0 ... done.<br>Read-only space ends at 0x94612560, 6169952 bytes.<br>Moving pre-ordered read-write objects to shared space at 0x94830000 ... done.<br>Moving read-write objects to shared space at 0x94ea64a0 ... done.<br>Moving String objects to shared space at 0x94ee3708 ... done.<br>Read-write space ends at 0x94f27448, 7304264 bytes.<br>Updating references to shared objects ... done.
</pre>
                            <div>
                                For many users, this can make a tremendous difference in startup time, since all that extra class data remains available in memory. You may need to specify the -d32 or -client options along with the -Xshare option. Play with those and the other -Xshare modes to see if it helps your situation.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Delay or disable JRuby's JIT</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                An interesting side effect of JRuby's JIT is that it sometimes actually <i>slows</i> execution for really short runs. The compiler isn't free, obviously, nor is the cost of loading, verifying, and linking the resulting JVM bytecode. If you have a very short command that touches a lot of code, you might want to try disabling or delaying the JIT.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                Disabling is easy: pass the -X-C flag or set the jruby.compile.mode property to "OFF":
                            </div>
                            <pre>
~/projects/jruby ➔ time jruby -S gem install rake<br>Successfully installed rake-0.8.7<br>1 gem installed<br>Installing ri documentation for rake-0.8.7...<br>Installing RDoc documentation for rake-0.8.7...<br><br>real 0m13.188s<br>user 0m12.342s<br>sys 0m0.685s<br><br>~/projects/jruby ➔ time jruby -X-C -S gem install rake<br>Successfully installed rake-0.8.7<br>1 gem installed<br>Installing ri documentation for rake-0.8.7...<br>Installing RDoc documentation for rake-0.8.7...<br><br>real 0m12.590s<br>user 0m12.342s<br>sys 0m0.583s
</pre>
                            <div>
                                This doesn't generally give you a huge boost, but it can be enough to keep you from going mad.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Avoid spawning "sub-rubies"</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                It's a fairly common idiom for Rubyists to spawn a Ruby subprocess using Kernel#system, Kernel#exec, or backquotes. For example, you may want to prepare a clean environment for a test run. That sort of scenario is perfectly understandable, but spawning many sub-rubies can take a tremendous toll on overall runtime.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                When JRuby sees a #system, #exec, or backquote starting with "ruby", we will attempt to run it in the same JVM using a new JRuby instance. Because we have always supported "multi-VM" execution (where multiple isolated Ruby environments share a single process), this can make spawning sub-Rubies considerably faster. This is, in fact, how JRuby's Nailgun support (more on that later) keeps a single JVM "clean" for multiple JRuby command executions. But even though this can improve performance, there's still a cost for starting up those JRuby instances, since they need to have fresh, clean core classes and a clean runtime.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                The worst-case scenario is when we detect that we can't spin up a JRuby instance in the same process, such as if you have shell redirection characters in the command line (e.g. system 'ruby -e blah &gt; /dev/null'). In those cases, we have no choice but to launch an entirely new JRuby process, complete with a new JVM, and you'll be paying the full zero-to-running cost.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                If you're able, try to limit how often you spawn "sub-rubies" or use tools like Nailgun or spec-server to reuse a given process for multiple hits.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Do less at startup</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                This is a difficult tip to follow, since often it's not your code doing so much at startup (and usually it's RubyGems itself). One of the sad truths of JRuby is that because we're based on the JVM, and the JVM takes a while to warm up, code executed early in a process runs a lot slower than code executed later. Add to this the fact that JRuby doesn't JIT Ruby code into JVM bytecode until it's been executed a few times, and you can see why cold performance is not one of JRuby's strong areas.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                It may seem like delaying the inevitable, but doing less at startup can have surprisingly good results for your application. If you are able to eliminate most of the heavy processing until an application window starts up or a server starts listening, you may avoid (or spread out) the cold performance hit. Smart use of on-disk caches and better boot-time algorithms can help a lot, like saving a cache of mostly-read-only data rather than reloading and reprocessing it on every boot.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Try using Nailgun</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                In JRuby 1.3, we officially shipped support for Nailgun. Nailgun is a small library and client-side tool that reuses a single JVM for multiple invocations. With Nailgun, small JRuby command-line invocations can be orders of magnitude faster. Have a look at my article on <a href="http://blog.headius.com/2009/05/jruby-nailgun-support-in-130.html">Nailgun in JRuby 1.3.0</a> for details.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                Nailgun seems like a magic bullet, but unfortunately it does little to help certain common cases like booting RubyGems or starting up Rails (such as when running tests). It also can't help cases where you are causing lots of sub-rubies to be launched. Your best bet is to give it a try and let us know if it helps.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Play around with JVM flags</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                There's scads of JVM flags that can improve (or degrade) startup time. For a good list of flags you can play with, see my article on <a href="http://blog.headius.com/2009/01/my-favorite-hotspot-jvm-flags.html">my favorite JVM flags</a>, paying special attention to the heap-sizing and GC flags. If you find combinations that really help your application start up faster, let us know!
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Help us find bottlenecks</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                The biggest advances in startup-time performance have come from users like you investigating the load process to see where all that time is going. If you do a little poking around and find that particular libraries take unreasonably long to start (or just do too much at startup) or if you find that startup time seems to be limited by something other than CPU (like if your hard drive starts thrashing madly or your memory bus is being saturated) there may be improvements possible in JRuby or in the libraries and code you're loading. Dig a little...you may be surprised what you find.
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                Here's a few JRuby flags that might help you investigate:
                            </div>
                            <div>
                                <ul>
                                    <li>--sample turns on the JVM's sampling profiler. It's not super accurate, but if there's some egregious bottleneck it should rise to the top.
                                    </li>
                                    <li>-J-Xrunhprof:cpu=times turns on the JVM's instrumented profiler, saving profile results to java.hprof.txt. This slows down execution tremendously, but can give you more accurate low-level timings for JRuby and JDK code.
                                    </li>
                                    <li>-J-Djruby.debug.loadService.timing=true turns on timing of all requires, showing fairly accurately where boot-time load costs are heaviest.
                                    </li>
                                    <li>On Windows, where you may not have a "time" command, pass -b to JRuby (as in 'jruby -b ...') to print out a timing of your command's runtime execution (excluding JVM boot time).
                                    </li>
                                </ul>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                <b>Let us help you!</b>
                            </div>
                            <div>
                                <br>
                            </div>
                            <div>
                                Sometimes, there's an obvious misconfiguration or bug in JRuby that causes an application to start up unreasonably slowly. If startup time seems drastically different than what you've seen here, there's a good chance something's wrong with your setup. Post your situation to the JRuby mailing list or find us on IRC, and we (along with other JRuby users) will do our best to help you.
                            </div>
                            <div>
                                <img width="1" height="1" src="https://blogger.googleusercontent.com/tracker/20975090-2863999783593463066?l=blog.headius.com" alt="">
                            </div>
                        </blockquote>
                    </div>
                    <p class="bookmark-source">
                        Source: <a href="http://blog.headius.com/2010/03/jruby-startup-time-tips.html">http://blog.headius.com/2010/03/jruby-startup-time-tips.html</a>
                    </p>
                </div>
            </article>

            <nav id="post-nav">


            </nav>
        </section>

        <footer id="site-footer" class="nocontent">
            <p>
                This site is purely my personal work and does not reflect the
                views of my employer.
            </p>
            <p class="license">
                <a class="icon" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width: 0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png"></a>
                This work is licensed under a
                <a rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported
                    License</a>.
            </p>
        </footer>

        <script async src="/static/js/common.js"></script>
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js" integrity="sha256-hj+5FRlAuvAFANiefn0PpJYCkV1X4QT9EgiPd+6QnCw=" crossorigin="anonymous"></script>
    </body>
</html>
