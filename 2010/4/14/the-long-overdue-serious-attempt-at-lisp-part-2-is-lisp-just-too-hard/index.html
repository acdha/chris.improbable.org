<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>
            The long-overdue serious attempt at Lisp, part 2: is Lisp just too hard?
        </title>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="/static/css/main.min.css" type="text/css" media="all"><!--[if lte IE 8]>
            <link rel="stylesheet" href="/static/css/ie-fixes.css" type="text/css" media="all">
            <script src="/static/js/html5shiv.js"></script>
        <![endif]-->
        <meta http-equiv="last-modified" content="Wed, 14 Apr 2010 16:40:22 GMT">
        <link rel="alternate" type="application/atom+xml" title="All Posts (Atom)" href="/feeds/all.atom">
        <link rel="alternate" type="application/rss+xml" title="All Posts (RSS)" href="/feeds/all.rss">
        <link rel="icon" type="image/jpeg" sizes="287x287" href="/static/img/favicon-287x287.jpg">
        <link rel="icon" type="image/jpeg" sizes="128x128" href="/static/img/favicon-128x128.jpg">
        <script type="application/javascript">
var _prum={id:"5166be01e6e53d1007000001"};var PRUM_EPISODES=PRUM_EPISODES||{};PRUM_EPISODES.q=[];PRUM_EPISODES.mark=function(b,a){PRUM_EPISODES.q.push(["mark",b,a||new Date().getTime()])};PRUM_EPISODES.measure=function(b,a,b){PRUM_EPISODES.q.push(["measure",b,a,b||new Date().getTime()])};PRUM_EPISODES.done=function(a){PRUM_EPISODES.q.push(["done",a])};PRUM_EPISODES.mark("firstbyte");(function(){var b=document.getElementsByTagName("script")[0];var a=document.createElement("script");a.type="text/javascript";a.async=true;a.charset="UTF-8";a.src="//rum-static.pingdom.net/prum.min.js";b.parentNode.insertBefore(a,b)})();
        </script>
    </head>
    <body class="blog post_detail" itemscope itemtype="http://schema.org/BlogPosting">
        <nav id="site-nav">
            <header id="about">
                <h1>
                    <a href="/about/">Chris Adams</a>
                </h1>
                <h2>
                    Programmer, cyclist, photographer
                </h2>
            </header>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/feeds/all.atom" title="Site Feed">Site Feed</a>
                </li>
            </ul>
            <ul class="social-networks">
                <li>
                    <a href="https://github.com/acdha" rel="me">Github</a>
                </li>
                <li>
                    <a href="http://bitbucket.org/acdha" rel="me">Bitbucket</a>
                </li>
                <li>
                    <a href="http://delicious.com/acdha" rel="me">del.icio.us</a>
                </li>
                <li>
                    <a href="http://twitter.com/acdha" rel="me">Twitter</a>
                </li>
                <li>
                    <a href="https://plus.google.com/116562742092842686896?rel=author" rel="me">Google+</a>
                </li>
                <li>
                    <a href="http://www.flickr.com/photos/acdha" rel="me">Flickr</a>
                </li>
                <li>
                    <a href="http://www.linkedin.com/in/acdha" rel="me">LinkedIn</a>
                </li>
                <li>
                    <a href="http://connect.garmin.com/explore?owner=acdha" rel="me">Garmin Connect</a>
                </li>
            </ul>
            <div id="site-search"></div>
        </nav>
        <section id="main">
            <article class="post">
                <header>
                    <meta itemprop="dateCreated" content="2010-04-14T12:40:22-04:00">
                    <meta itemprop="dateModified" content="2010-04-14T12:40:22-04:00"><time class="date" itemprop="datePublished" datetime="2010-04-14T16:40:22+00:00">Apr 14</time>
                    <h2 itemprop="title">
                        The long-overdue serious attempt at Lisp, part 2: is Lisp just too hard?
                    </h2>
                </header>
                <div class="body" itemprop="articleBody">
                    <div class="googlereader description" data-google-id="tag:google.com,2005:reader/item/319897835fce6dd3">
                        <blockquote>
                            <div>
                                <p>
                                    First, thanks to all of you who advised me on <a href="http://reprog.wordpress.com/2010/03/23/the-long-overdue-serious-attempt-at-lisp-part-1-which-lisp/">what Lisp to learn</a>. &nbsp;I found it really helpful to get so many different perspectives, and I hope those of you who advocated Common Lisp or Clojure will not be offended that in the end I chose Scheme. &nbsp;(Actually, I bet you won’t be: one of the pleasant aspects of the comments on that article was the consistent sense that all the comments were of the form “I prefer <em>this</em> Lisp, but if you learn any of them that’ll be great.”)
                                </p>
                                <p>
                                    A few people suggested that I should learn <em>all</em> the different Lisps rather than just picking one. &nbsp;As a looong-term project, I guess I agree with that; but here and now, I need to pick one and run with it: and Scheme it is, for its minimality, elegance and purity. &nbsp;I figured that if I learn Scheme it’ll be easier to move from that to Common Lisp later rather than vice versa. &nbsp;(I was tempted by Clojure, too, not least because there is only one of it, but it feels just a bit too new-fangled to be a good starting point.)
                                </p>
                                <p>
                                    So two days ago I started working my way through R. Kent Dybvig’s highly regarded book&nbsp;<em>The Scheme Programming Language</em> [<a href="http://www.amazon.com/exec/obidos/ASIN/026251298X/thedinosaurrea0a">amazon.com</a>, <a href="http://www.amazon.co.uk/exec/obidos/ASIN/026251298X/thedinosaurreadi">amazon.co.uk</a>].
                                </p>
                                <p>
                                    <a href="http://reprog.files.wordpress.com/2010/04/the-scheme-programming-language.png"><img title="the-scheme-programming-language" src="http://reprog.files.wordpress.com/2010/04/the-scheme-programming-language.png?w=369&amp;h=475" alt="" width="369" height="475"></a>
                                </p>
                                <p>
                                    The nice people at MIT Press sent me a review copy, which I am pleased about because <a href="http://reprog.wordpress.com/2010/03/01/programming-books-part-1-coders-at-work/">I learn better from books than from websites</a>; but for those of you who want to play along at home but don’t want to buy the book, its content is very helpfully online, free, at ﻿﻿﻿﻿<a href="http://www.scheme.com/tspl4/">http://www.scheme.com/tspl4/</a>.
                                </p>
                                <h2>
                                    About the book
                                </h2>
                                <p>
                                    I chose this book from among several that I was offered, in part because it seems to be modelled on Kernighan and Ritche’s classic <em>The C Programing Language</em>, which <a href="http://reprog.wordpress.com/2010/04/06/programming-books-part-4-the-c-programming-language/">I am a big fan of</a>. &nbsp;The title is an obvious nod, but several Amazon reviewers also made the point that it takes much the same approach, as does one of the jacket quotes:
                                </p>
                                <blockquote>
                                    <p>
                                        “Kent Dybvig’s The Scheme Programming Language is to Scheme what Kernighan and Ritchie’s The C Programming Language is to C. &nbsp;Dybvig’s book is either for the novice or serious Scheme programmer.
                                    </p>
                                    <p style="padding-left:30px">
                                        – Daniel P. Friedman, Department of Computer Science, Indiana University.
                                    </p>
                                </blockquote>
                                <p>
                                    I’d have to guess that Daniel P. Friedman is one of those serious Scheme programmers, though, because speaking as a novice, I am not finding it particularly easy going. &nbsp;In part, that’s no bad thing: it’s slow because it’s dense. &nbsp;Although I am only 54 pages in, that’s because those pages are worth several hundred pages of a lesser book — there’s no fluff, a lot of new material on each page, and plenty of exercises.
                                </p>
                                <p>
                                    On the other hand, there are a few places where it seems the author is taking too much for granted, probably because his own familiarity with Scheme culture makes it hard for him to recognise which concepts the rest of us are not already familiar with. &nbsp;For example, the book talks a lot of about Scheme’s “syntactic forms” without saying what a syntactic form actually <em>is</em>. &nbsp;The answer only gradually emerges from among the various examples, and it turns out that syntactic forms have nothing to do with syntax or with form. &nbsp;I really could have done with being told that up front.
                                </p>
                                <p>
                                    [For those who don't know: there's only one form of syntax in Scheme, the S-expression. &nbsp;"Syntactic forms" turn out to be evaluation regimes for S-expressions. &nbsp;For example, whereas in the most typical form, "procedure application", expressions like <span style="color:#800000">(cons a b)</span> evaluate every member of the top-level list before applying the procedure, the expression&nbsp;<span style="color:#800000">(quote (a b c))</span> does not evaluate its argument because it uses the "quote" syntactic form; similarly, <span style="color:#800000">(or a b c d)</span> uses another form such that it evaluates <span style="color:#800000">a</span>, but then continues to evaluate <span style="color:#800000">b</span> and the remaining arguments, in sequence, only if all preceding arguments were false -- which is why <span style="color:#800000">(or #t (/ 1 0))</span> does not raise an exception.]
                                </p>
                                <p>
                                    <a href="http://reprog.files.wordpress.com/2010/04/3622072962_ec0fff100e.jpg"><img title="3622072962_ec0fff100e" src="http://reprog.files.wordpress.com/2010/04/3622072962_ec0fff100e.jpg?w=300&amp;h=201" alt="" width="300" height="201"></a>
                                </p>
                                <h2>
                                    How to read the book?
                                </h2>
                                <p>
                                    I am actually not clear in my own mind how to read this book. &nbsp;I’ve said before that I like books precisely because they get me away from the keyboard so that I focus on what I am learning rather than, well, all the other good stuff that distracts me from learning when I have access to my email and Hacker News. &nbsp;But it feels like I’m going to learn more from this book, and hammer home the unfamiliar ideas more emphatically, if I do all the exercises as I go through. &nbsp;And because they are so liberally sprinkled, that means going back to the keyboard every page or two.
                                </p>
                                <p>
                                    With <a href="http://reprog.wordpress.com/2010/04/12/leaky-abstractions-in-frameworks/">the Rails book</a>, which I’m reading in parallel with this, I’ve been reading a chapter at a time away from the keyboard, then going back over the same material with my computer, making all the application changes that the book describes. &nbsp;That’s worked pretty well with something like Rails, where what I am learning is techniques and conventions; I am not sure it’ll work for Scheme, where I am learning <em>concepts</em>. &nbsp;I think I might need that to be more interactive.
                                </p>
                                <p>
                                    So at the moment I am thinking that maybe the thing to do is put the computer aside completely and just read; then, when I’ve finished reading the whole book, go back over the whole thing with the computer, doing the exercises. &nbsp;That sounds long-winded, sure; but then what I am trying to do is no small thing — not just to learn enough fragments of Scheme that I can customise GNU Robots, but to fully learn, to <em>master</em>, the language — to become comfortable with the concepts rather than merely tolerating them. &nbsp;And maybe it’s unrealistic to think that I ought to be able to achieve that high goal with a single pass through a 491-page book, however dense.
                                </p>
                                <p>
                                    But in fact, I’ve come up with another way of reading the book — a yet more inefficient approach that will require me to make <em>three</em> passes! &nbsp;And yet which will, if it works out right, perhaps get me to my goal more quickly. &nbsp;(Hmm. &nbsp;Sounds like I may be <a href="http://reprog.wordpress.com/2010/04/09/slicing-your-2d-classfunction-matrix-vertically-or-horizontally/">over-Fowlering</a> the simple process of reading a book?) &nbsp;Anyway, read on to find out about the three-pass algorithm.
                                </p>
                                <p>
                                    <a href="http://reprog.files.wordpress.com/2010/04/sashimi_moriawase700.jpg"><img title="sashimi_moriawase700" src="http://reprog.files.wordpress.com/2010/04/sashimi_moriawase700.jpg?w=300&amp;h=229" alt="" width="300" height="229"></a>
                                </p>
                                <h2>
                                    About the language
                                </h2>
                                <p>
                                    So far I have mixed feelings about Scheme (and about Lisp in general, bearing in mind that I don’t have more than a cursory Lisp background, and that I am learning Scheme as a Lisp.) &nbsp;The economy and elegance are already obvious even this early in the process — for example, there is certainly something clean about just using <span style="color:#800000">(define <em>name</em> (lambda (<em>args</em>) <em>body</em>)))</span> rather than having a separate <span style="color:#800000">defun</span> — but even discounting such trivial irritants as the <span style="color:#800000">fail</span> function being called&nbsp;<span style="color:#800000">assertion-violation</span>, there are … issues.
                                </p>
                                <p>
                                    I suppose I must be frank: I hate all the parentheses and the prefix operators. &nbsp;Yes, yes, I know those are Clueless Newb complaints. &nbsp;I know all about how Lisp syntax is powerful because it’s general and how prefix notation is just as expressive as infix and all that stuff — I’ve read my <a href="http://www.paulgraham.com/iflisp.html">Paul Graham articles</a>. &nbsp;I hesitated even to mention it here, but, look, dammit, no, it won’t do.
                                </p>
                                <p>
                                    Let’s read some COBOL together!
                                </p>
                                <p style="padding-left:30px">
                                    <span style="color:#800000">MULTIPLY UNIT-PRICE BY QUANTITY GIVING TOTAL-PRICE</span>
                                </p>
                                <p>
                                    That is bad syntax. &nbsp;It’s verbose and lumpen. &nbsp;We all know that and (I assume) agree on it, and no-one defends COBOL’s arithmetic and assignment syntax as acceptable any more. &nbsp;We all agree that it’s objectively better to say:
                                </p>
                                <p style="padding-left:30px">
                                    <span style="color:#800000">totalPrice = unitPrice * quantity</span>
                                </p>
                                <p>
                                    And yet somehow Lisp’s mystique is so great that we all feel obliged to behave as though we believed that it’s equally good to say:
                                </p>
                                <p style="padding-left:30px">
                                    <span style="color:#800000">(define totalPrice (* unitPrice quantity))</span>
                                </p>
                                <p>
                                    But it isn’t. &nbsp;It just isn’t. &nbsp;Syntax <em>matters</em>.
                                </p>
                                <p>
                                    And that goes double for non-trivial arithmetic. &nbsp;The very first exercise in the book is:
                                </p>
                                <div style="padding-left:30px">
                                    <strong>Exercise 2.1.1.</strong> Convert the following arithmetic expressions into Scheme expressions and evaluate them.
                                </div>
                                <div style="padding-left:30px">
                                    <em>a</em>. 1.2 × (2 – 1/3) + -8.7
                                </div>
                                <div style="padding-left:30px">
                                    <em>b</em>. (2/3 + 4/9) ÷ (5/11 – 4/3)
                                </div>
                                <div style="padding-left:30px">
                                    <em>c</em>. 1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))
                                </div>
                                <div style="padding-left:30px">
                                    <em>d</em>. 1 × -2 × 3 × -4 × 5 × -6 × 7
                                </div>
                                <p>
                                    Sorry, but that is just dumb. &nbsp;Arithmetic isn’t something you should have to devote precious brain-cycles to, it should just be there. &nbsp;The solution to part <em>a</em> is of course:
                                </p>
                                <p style="padding-left:30px">
                                    <span style="color:#800000">(+ (* 1.2 (- 2 1/3)) -8.7)</span>
                                </p>
                                <p>
                                    No-one better tell me that that’s not objectively inferior to the infix version. &nbsp;(I bet someone will, though). &nbsp;And it gets way, way worse once you start writing actual programs as opposed to mere arithmetic expressions.
                                </p>
                                <p>
                                    <a style="text-decoration:none" href="http://reprog.files.wordpress.com/2010/04/spider-roll-at-tora-sushi.jpg"><img title="spider-roll-at-tora-sushi" src="http://reprog.files.wordpress.com/2010/04/spider-roll-at-tora-sushi.jpg?w=300&amp;h=200" alt="" width="300" height="200"></a>
                                </p>
                                <p>
                                    I will return to the subject of Lisp/Scheme syntax shortly, but first I want to talk about the problem of …
                                </p>
                                <h2>
                                    Learning two things at once
                                </h2>
                                <p>
                                    I think I could cope with Scheme syntax. &nbsp;I don’t say that I could ever learn to love it, but I think I could cope. &nbsp;But of course that is the very small tip of the iceberg of learning this language. &nbsp;In fact it’s basically trivial — the real issue is learning to think functionally. &nbsp;That is a much bigger and more important matter; and more generally applicable, too. &nbsp;When <a href="http://www.catb.org/~esr/faqs/hacker-howto.html#skills1">Eric S. Raymond wrote</a>:
                                </p>
                                <blockquote>
                                    <p>
                                        LISP is worth learning for a different reason — the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot.
                                    </p>
                                </blockquote>
                                <p>
                                    He was not talking about learning to love parentheses, but about learning functional programming — learning to think about functions as entities in their own right rather than little gobbets of functionality clinging for dear life to the sides of classes. &nbsp;The <em>point</em> of Lisp is closures, lambdas, continuations, list comprehensions, monads and all the rest of the bestiary of terrifying yet alluring functional concepts. &nbsp;You know — all those concepts that your functional-programmer friends like to drop casually into the conversation to subtly remind you that you’re not as awesome as they are. &nbsp;<a href="http://reprog.wordpress.com/2010/02/27/closures-finally-explained/">Closures I am happy with</a>, thanks to Ruby; lambdas I understand with my mind but do not love with my heart; continuations I only understand as being “sort of like <span style="color:#800000">jmpbuf</span>s”; list comprehensions I can’t see the point of; and monads I … uh, lemme see now, I … &nbsp;<em>HEY! &nbsp;WHAT’S THAT OVER THERE!!!</em> [Points into the distance, turns and sprints for safety while you're looking the other way.]
                                </p>
                                <p>
                                    This is big and important stuff. &nbsp;Thanks to my closures-in-Ruby epiphany, I now understand that your functional-programmer friends really <em>are</em> more awesome than me in the sense that they have more tools in their kit. &nbsp;In a frighteningly short time, I have flipped across into that segment of the population that wonders how you can ever get anything done in a language without closures (and, yes, Java, I am looking at you). &nbsp;What if monads turn out to be similarly useful? &nbsp;I don’t want to miss out on them.
                                </p>
                                <p>
                                    But the problem is that I am trying to learn to love Scheme’s dumb syntax and its powerful abstractions both at the same time. &nbsp;And as any good scientist will tell you, you can only really understand what you’re doing when you change one variable at a time, holding all the other constant. &nbsp;So I find myself thinking: how can I learn only one of those things at a time?
                                </p>
                                <p>
                                    <a style="text-decoration:none" href="http://reprog.files.wordpress.com/2010/04/s3yu35u.jpg"><img title="s3yu35u" src="http://reprog.files.wordpress.com/2010/04/s3yu35u.jpg?w=300&amp;h=225" alt="" width="300" height="225"></a>
                                </p>
                                <h2>
                                    Learning one thing at once
                                </h2>
                                <p>
                                    It’s obvious that there are two paths: learn Lisp syntax first and then add in the functional concepts; or learn functional concepts first and then learn the Lisp syntax. &nbsp;At first I thought that the syntax-first approach was impossible because there is no language with Lisp syntax but imperative idioms — until it hit me that that’s pretty much a description of Emacs Lisp. &nbsp;As <a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">Steve Yegge’s handy tutorial</a> shows, the Lispiness of Emacs Lisp is rather skin deep, and it’s pretty unashamedly all about the side-effect.
                                </p>
                                <p>
                                    So one approach for me to take would be to learn Emacs Lisp properly — properly enough to write a non-trivial extension, like for instance a major mode for editing ScottKit source files, and maybe for compiling and running the resulting games.
                                </p>
                                <p>
                                    The opposite approach would be to take a language with actual syntax but which also supports functional concepts, and learn to use that functionally. &nbsp;Specifically, my idea is to do all the exercises from <em>The Scheme Programming Language</em> in Ruby, and only then to go back and do them in Scheme. &nbsp;And this of course is the the three-pass approach to reading the book that I alluded to earlier: once through with just the book; once more with the computer, learning functional programming by doing the exercises in Ruby; and then the third time, doing the exercises again but this time in Scheme. &nbsp;(A useful side-effect of such an approach would be that I’d discover the hard way where Ruby doesn’t have the necessary support for functional programming. &nbsp;But I know that it has closures, lambdas and continuations, and I don’t really see how list comprehensions are much different from a composition of closures, so I should be able to get some way before running into a brick wall.)
                                </p>
                                <p>
                                    So far, I am not clear in my own mind what path I should take: learn to love Lisp syntax by writing Elisp? &nbsp;Learn functional programming by doing Scheme exercises in Lisp? &nbsp;Or just keep on ploughing through the book, continuing to do the Scheme exercises in Scheme, and hope that the syntax becomes tolerable as a side-effect while I am learning all the good stuff? &nbsp;(The second approach is appealing for the same reason that I found it satisfying, when I was at school, to win the music prize by playing Hadyn’s Trumpet Concerto on clarinet.)
                                </p>
                                <p>
                                    Advice will be welcome at this point.
                                </p>
                                <p>
                                    <a href="http://reprog.files.wordpress.com/2010/04/chef-maki-spyder-2.jpg"><img title="CHEF-MAKI-Spyder-2" src="http://reprog.files.wordpress.com/2010/04/chef-maki-spyder-2.jpg?w=480&amp;h=400" alt="" width="480" height="400"></a>I do have one final point to make, but I’ve decided to save that for a separate article, because it’s fairly self-contained and potentially a bit controversial, and I don’t want comments on that one subject to overwhelm whatever useful advice I might get in response to this entry.
                                </p>
                                <p>
                                    So — advise me!
                                </p>
                                <h2>
                                    Update (a few hours later)
                                </h2>
                                <p>
                                    As I continue to work my way through the exercises (using Scheme itself at least for now), I run into a problem: for exercise 2.9.3 I need <span style="color:#800000">set-car!</span>, which the purity-fascist maintainers of PLT Scheme removed in release 4.0. &nbsp;No doubt there is a secret incantation to undo this change, but I can’t immediately see what it is. &nbsp;Can anyone point me to it?
                                </p>
                                <p>
                                    &lt;rant&gt;
                                </p>
                                <p style="padding-left:30px">
                                    I just hate this kind of thing. &nbsp;It’s like the absence of <span style="color:#800000">goto</span> in Ruby. &nbsp;It’s very nice that language implementors give me “better” ways to do these things, but is it really too much to ask that they treat me like an adult and let me be the judge of how I want to write <em>my own freakin’ code!</em>? &nbsp;Language implementors, please remember these very wise words: <strong>mechanism, not policy</strong>.
                                </p>
                                <p>
                                    &lt;/rant&gt;
                                </p>
                            </div>
                        </blockquote>
                    </div>
                    <p class="bookmark-source">
                        Source: <a href="http://reprog.wordpress.com/2010/04/14/the-long-overdue-serious-attempt-at-lisp-part-2-is-lisp-just-too-hard">http://reprog.wordpress.com/2010/04/14/the-long-overdue-serious-attempt-at-lisp-part-2-is-lisp-just-too-hard</a>
                    </p>
                </div>
            </article>
            <nav id="post-nav"></nav><script id="discus-javascript">
    var disqus_shortname = 'improbable';

                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                    document.getElementsByTagName('body')[0].appendChild(dsq);
                })();
            </script><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            <div id="disqus_thread"></div>
        </section>
        <footer id="site-footer" class="nocontent">
            <p>
                This site is purely my personal work and does not reflect the views of my employer.
            </p>
            <p class="license">
                <a class="icon" rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png"></a> This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
            </p>
        </footer><script async="" defer src="/static/js/common.js">
</script><script id="google-analytics">
    var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-2097834-1']);
            _gaq.push(['_setDomainName', 'improbable.org']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
    </body>
</html>
