<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>
            Concur.next — Eleven Theses on Clojure
        </title>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="/static/css/main.min.css" type="text/css" media="all"><!--[if lte IE 8]>
            <link rel="stylesheet" href="/static/css/ie-fixes.css" type="text/css" media="all">
            <script src="/static/js/html5shiv.js"></script>
        <![endif]-->
        <meta http-equiv="last-modified" content="Fri, 04 Dec 2009 18:25:50 GMT">
        <link rel="alternate" type="application/atom+xml" title="All Posts (Atom)" href="/feeds/all.atom">
        <link rel="alternate" type="application/rss+xml" title="All Posts (RSS)" href="/feeds/all.rss">
        <link rel="icon" type="image/jpeg" sizes="287x287" href="/static/img/favicon-287x287.jpg">
        <link rel="icon" type="image/jpeg" sizes="128x128" href="/static/img/favicon-128x128.jpg">
        <script type="application/javascript">
var _prum={id:"5166be01e6e53d1007000001"};var PRUM_EPISODES=PRUM_EPISODES||{};PRUM_EPISODES.q=[];PRUM_EPISODES.mark=function(b,a){PRUM_EPISODES.q.push(["mark",b,a||new Date().getTime()])};PRUM_EPISODES.measure=function(b,a,b){PRUM_EPISODES.q.push(["measure",b,a,b||new Date().getTime()])};PRUM_EPISODES.done=function(a){PRUM_EPISODES.q.push(["done",a])};PRUM_EPISODES.mark("firstbyte");(function(){var b=document.getElementsByTagName("script")[0];var a=document.createElement("script");a.type="text/javascript";a.async=true;a.charset="UTF-8";a.src="//rum-static.pingdom.net/prum.min.js";b.parentNode.insertBefore(a,b)})();
        </script>
    </head>
    <body class="blog post_detail" itemscope itemtype="http://schema.org/BlogPosting">
        <nav id="site-nav">
            <header id="about">
                <h1>
                    <a href="/about/">Chris Adams</a>
                </h1>
                <h2>
                    Programmer, cyclist, photographer
                </h2>
            </header>
            <ul class="links">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/feeds/all.atom" title="Site Feed">Site Feed</a>
                </li>
            </ul>
            <ul class="social-networks">
                <li>
                    <a href="https://github.com/acdha" rel="me">Github</a>
                </li>
                <li>
                    <a href="http://bitbucket.org/acdha" rel="me">Bitbucket</a>
                </li>
                <li>
                    <a href="http://delicious.com/acdha" rel="me">del.icio.us</a>
                </li>
                <li>
                    <a href="http://twitter.com/acdha" rel="me">Twitter</a>
                </li>
                <li>
                    <a href="https://plus.google.com/116562742092842686896?rel=author" rel="me">Google+</a>
                </li>
                <li>
                    <a href="http://www.flickr.com/photos/acdha" rel="me">Flickr</a>
                </li>
                <li>
                    <a href="http://www.linkedin.com/in/acdha" rel="me">LinkedIn</a>
                </li>
                <li>
                    <a href="http://connect.garmin.com/explore?owner=acdha" rel="me">Garmin Connect</a>
                </li>
            </ul>
            <div id="site-search"></div>
        </nav>
        <section id="main">
            <article class="post">
                <header>
                    <meta itemprop="dateCreated" content="2009-12-01T15:00:00-04:00">
                    <meta itemprop="dateModified" content="2009-12-01T15:00:00-04:00"><time class="date" itemprop="datePublished" datetime="2009-12-01T19:00:00+00:00">Dec 01</time>
                    <h2 itemprop="title">
                        Concur.next — Eleven Theses on Clojure
                    </h2>
                </header>
                <div class="body" itemprop="articleBody">
                    <div class="googlereader description" data-google-id="tag:google.com,2005:reader/item/589b7993dde746ad">
                        <blockquote>
                            <div>
                                <p>
                                    I’ve been banging away on Clojure for a few days now, and while it would obviously take months of study and grinding through a big serious real-world software project to become authoritative, I think that what I’ve learned is useful enough to share.
                                </p>
                                <p>
                                    [This is part of the <a href="http://www.tbray.org/ongoing/When/200x/2009/09/27/Concur-dot-next">Concur.next series</a>.]
                                </p>
                                <h2>
                                    1. It’s the Best Lisp Ever
                                </h2>
                                <p>
                                    I don’t see how this can be a controversial statement. Issues of language-design aside, every other Lisp I’ve worked with has been hobbled by lacklustre libraries and poor integration with the rest of the IT infrastructure. Running on the Java platform makes those problems go away, <i>poof!</i>
                                </p>
                                <p>
                                    Let’s assume hypothetically that there are other Lisps where certain design choices are found to be better than Clojure’s. Well, you can pile all those design choices up on top of each other and the pile will have to be very high before they come close to balancing the value of Java’s huge library repertoire and ease of integration with, well, just about anything.
                                </p>
                                <h2>
                                    2. Being a Lisp Is a Handicap
                                </h2>
                                <p>
                                    There are a large number of people who find Lisp code hard to read. I’m one of them. I’m fully prepared to admit that this is a shortcoming in myself not Lisp, but I think the shortcoming is widely shared.
                                </p>
                                <p>
                                    Perhaps if I’d learned Lisp before plunging into the procedural mainstream, I wouldn’t have this problem&nbsp;—&nbsp;but it’s not clear the results of MIT’s decades-long experiment in doing so would support that hypothesis.
                                </p>
                                <p>
                                    I think it’s worse than that. In school, we all learn<br>
                                    3 + 4 = 7 and then<br>
                                    <i>sin(π/2) = 1</i><br>
                                    and then many of us speak languages with infix verbs. So Lisp is fighting uphill.
                                </p>
                                <p>
                                    It also may be the case that there’s something about some human minds that has trouble with thinking about data list-at-a-time rather than item-at-a-time and thus reacts poorly to constructs like
                                </p>
                                <pre>
<code>(apply merge-with +
  (pmap count-lines
    (partition-all *batch-size*
      (line-seq (reader filename)))))</code>
</pre>
                                <p>
                                    <i>[Update:]</i> Rich Hickey <a href="http://gist.github.com/247172">provides</a> some alternative and arguably more readable formulations of this code.
                                </p>
                                <p>
                                    I think I really totally understand the value of being <a href="http://en.wikipedia.org/wiki/Homoiconicity">homoiconic</a>, and the awesome power of macros, and the notion of the reader. I want to like Lisp; but I think readability is an insanely important characteristic in programming systems.
                                </p>
                                <p>
                                    Practically speaking, this means that it’d be hard for me to go out there on Sun’s (or Oracle’s) behalf and tell them that the way to take the best advantage of modern many-core hardware is to start with S-Expressions before breakfast.
                                </p>
                                <h2>
                                    3. Clojure’s Concurrency Features Are Awesome
                                </h2>
                                <p>
                                    They do what they say they’re going to do, they require amazingly little ceremony, and, near as I can tell, their design mostly frees you from having to worry about deadlocks and race conditions.
                                </p>
                                <p>
                                    Rich Hickey has planted a flag on high ground, and from here on in I think anyone who wants to make any strong claims about doing concurrency had better explain clearly how their primitives are distinguished from, or better than, Clojure’s.
                                </p>
                                <h2>
                                    4. Agents Are Better Than Refs or Atoms
                                </h2>
                                <p>
                                    I’m using these terms in a Clojure-specific way: Specifically, I mean <a href="http://clojure.org/agents">agents</a>, <a href="http://clojure.org/refs">refs</a>, and <a href="http://clojure.org/atoms">atoms</a>.
                                </p>
                                <p>
                                    Agents are not <a href="http://en.wikipedia.org/wiki/Actor_model">actors</a> nor are they processes in either the Operating-System or Erlang senses. I’m not actually sure how big a difference that makes; my suspicion is that programmers probably think about using all three in about the same way, and that’s OK.
                                </p>
                                <p>
                                    Anyhow, agents solve concurrency problems in the simplest possible way: By removing concurrency. Send functions to an agent and they’ll get executed one at a time in whatever order, taking the agent variable as their first argument, replacing its value with their output.
                                </p>
                                <p>
                                    Here is an example. I have a map (i.e. hash table) called <code>so-far</code> in which the keys are strings and the values are integers counting how many times each string has been encountered. If I use <code>refs</code> to protect both the hash table and the counters, I get code like this:
                                </p>
                                <pre>
<code> 1 (defn new-counter [ so-far target ]
 2   (dosync
 3     (if-let [ c (@so-far target) ]
 4       c
 5       (let [counter (ref 0) ]
 6         (ref-set so-far (assoc @so-far target counter))
 7         counter))))
 8
 9 (defn record [target so-far]
10   (if-let [ counter (@so-far target) ]
11     (incr counter)
12     (incr (new-counter so-far target))))</code>
</pre>
                                <p>
                                    Let’s start with the <code>record</code> function on Line 9. The <code>if-let</code> looks up the target in the hash, ignoring concurrency issues with <code>@</code>, and uses <code>incr</code> to bump the counter, if there’s one there. If there isn’t, it calls <code>new-counter</code> to make one.
                                </p>
                                <p>
                                    Lines 3 and 4, in <code>new-counter</code>, are where it gets interesting. Since everything’s running concurrently, we can’t just go ahead and bash a new counter into the <code>so-far</code> hash table, because somebody might have come along and done that already, recorded a few values even, so we’re at risk of throwing away data. So after we’ve locked things down with <code>dosync</code>, we check once again to see if the counter is there and if so, just return it. Otherwise we create the new counter, load it into the hash, and return it.
                                </p>
                                <p>
                                    On the other hand, consider the <code>agent</code>-based approach; once again we have a hash table called <code>so-far</code>, but protected by an agent. If the code wants to increment the value for some <code>target</code>, it says<br>
                                    <code>(send so-far add target)</code>
                                </p>
                                <p>
                                    This will eventually call the <code>add</code> function with the hash table (not a reference or anything, the actual table) as the first argument, and <code>target</code> as the second. Here’s <code>add</code>:
                                </p>
                                <pre>
<code>(defn add [so-far target]
  (if-let [count (so-far target)]
    (assoc so-far target (inc count))
    (assoc so-far target 1)))</code>
</pre>
                                <p>
                                    Considerably simpler, and nothing (concurrency-wise) can go wrong.
                                </p>
                                <p>
                                    I do have one nit with agents. Most of my code was infrastructure; a module that reads lines out of a file and passes them one at a time to a user-provided function. At one point, I made some of the code that fixes up the lines that span I/O-block boundaries agent-based, because it was simpler. Unfortunately that code also calls the user-provided function and when one of those also tried to send work off to an agent, everything blew up because you can’t have a <code>send</code> inside a <code>send</code>.
                                </p>
                                <p>
                                    Actually, I think my nit is more general; in an ideal world, concurrency primitives would all be orthogonal and friction-free. But anyhow it’s a nit, not an architectural black hole, I think.
                                </p>
                                <h2>
                                    5. Clojure Concurrency Does Buy Real-World Performance
                                </h2>
                                <p>
                                    The Wide Finder runs I was using to test were processing 45G of data in a way that turned out to be CPU-limited in Clojure <s>(I think due to inefficiencies in Java’s bytes-on-disk-to-String-objects pipeline, but I’m not sure).</s> So making this run fast on a high-core-count/low-clock-rate processor was actually a pretty useful benchmark.
                                </p>
                                <blockquote>
                                    <p>
                                        <i>[Update: Now I’m sure that the bytes-to-strings thing is <em>not</em> the problem; I’m getting much better times, it’s an interesting story and I’ll write it up.]</i>
                                    </p>
                                </blockquote>
                                <p>
                                    The single most important result: Clojure’s concurrency tools reduced the elapsed run-time by a factor of four on an eight-core system, with a very moderate amount of easy-to-read (for Lisp) code.
                                </p>
                                <h2>
                                    6. Performance is Wonky But It Doesn’t Matter
                                </h2>
                                <p>
                                    Some more results:
                                </p>
                                <ul>
                                    <li>
                                        <p>
                                            The amount of extra CPU burned to achieve the 4× speedup was remarkably high, more than doubling the CPU of the whole job.
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            The costs of concurrency, as functions of whether you use refs, or map/reduce, or agents, and also of block-size and thread-count and so on, are wildly variable and exhibit no obvious pattern.
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Well, agents did seem to be quite a bit more expensive than refs. But refs were pretty cheap; a low-concurrency map/reduce approach was not dramatically slower than doing the Simplest Thing That Could Possibly Work with refs.
                                        </p>
                                    </li>
                                </ul>
                                <p>
                                    These results are irrelevant. Remember, this is Clojure <strong>1.0</strong> we’re working with. If we determine that the throughput of the agent handlers is unacceptable, or that the STM-based infrastructure is consuming excessive CPU overhead, I’m quite confident that can be fixed. For example, we could lock Rich Hickey in a basement and put him on a tofu-and-lettuce diet.
                                </p>
                                <h2>
                                    7. The Implementation Is Good
                                </h2>
                                <p>
                                    I pushed Clojure hard enough to have a couple of subtle code bugs blow out the whole JVM, which takes considerable blowing-out on a Sun T2000. But the bugs were mine not Clojure’s. In the course of quite a few days pounding away at this thing with big data and tons of concurrency, I only observed one bug that I’m pretty sure is in Clojure, and then I couldn’t reproduce it.
                                </p>
                                <p>
                                    Also, I never observed code in Clojure running significantly slower than the equivalent code in Java.
                                </p>
                                <p>
                                    So if I’m wrong and there’s scope for a Lisp to take hold in the mainstream, Clojure would really be a good Lisp to bet on.
                                </p>
                                <h2>
                                    8. The Documentation Is OK
                                </h2>
                                <p>
                                    The current sources are Stuart Halloway’s <a href="http://pragprog.com/titles/shcloj/programming-clojure">Programming Clojure</a>, Mark Volkmann’s <a href="http://java.ociweb.com/mark/clojure/article.html">Clojure - Functional Programming for the JVM</a>, and of course the online <a href="http://clojure.org/api">API reference</a>.
                                </p>
                                <p>
                                    I used the book most, and while it’s well-written and accurate, it’s either missing some coverage or a little out of date, as I discovered whenever I published code and helpful commenters pointed out all the newer and better functions that I could have used. I also found the apps they built the tutorial examples around less than compelling.
                                </p>
                                <p>
                                    Also, you can look through the source code, which is mostly in Clojure, and even for someone like me who finds Lisp hard to read, that’s super-helpful. But it’s clear that there’s good scope for a “Camel” or “Pickaxe” style book to come along and grab the high ground.
                                </p>
                                <h2>
                                    9. The Community Is Excellent
                                </h2>
                                <p>
                                    As I’ve already observed, the Clojure community is terrific; we’ll see how well that stands the test of time. I suspect I may linger around #clojure even when I’ve moved on to other things, just because the company’s good.
                                </p>
                                <h2>
                                    10. The Tools Aren’t Bad
                                </h2>
                                <p>
                                    I used <a href="http://www.enclojure.org/">Enclojure</a> and I recommend it; having it set up and manage my REPL was super-convenient, and it never introduced any bugs or inconsistencies that I spotted. It’s also very early on in its life and there are rough spots, but really it’s good stuff.
                                </p>
                                <p>
                                    I gather that rather more people use Emacs and some favor of <a href="http://common-lisp.net/project/slime/">SLIME</a>, and I’m sure I would have been just fine with that too.
                                </p>
                                <h2>
                                    11. Tail Optimization Is Still a Red Herring
                                </h2>
                                <p>
                                    I wrote admiringly in <a href="http://www.tbray.org/ongoing/When/200x/2009/10/27/Recur">Tail Call Amputation</a> about the virtues of Clojure’s <code>recur</code> and <code>loop</code> forms, as opposed to traditional tail-call optimization. This is clearly a religious issue, and there’s lots of preaching in the comments to that piece. I read them all and I followed pointers, and here’s what I think:
                                </p>
                                <p>
                                    Clojure’s <code>loop</code>/<code>recur</code> delivers 80% of the value of TCO, with greater syntax clarity. Clojure’s <a href="http://clojure.org/api#toc569">trampoline</a> delivers 80% of the remaining 20%.
                                </p>
                                <p>
                                    Near as I can tell, that leaves state-machine implementation as the big outstanding case that you really need TCO for. I’ve done a ton of state-machine work in my career, and while I recognize that you <em>could</em> implement them with a bunch of trampolining tail-called routines, I’ve never understood why that’s better than expressing them in some sort of (usually sparse) array.
                                </p>
                                <p>
                                    So, my opinion is that post-Clojure, this argument is over. I suspect that this will convince exactly zero of the TCO fans, probably including Rich Hickey, and that once again the comments will fill up with people explaining how the real conclusion is that I don’t actually understand TCO. Oh well.
                                </p>
                                <h2>
                                    Thanks!
                                </h2>
                                <p>
                                    To Rich and the community for welcoming me and helping. I stuffed my code fragments into the SVN repository at the Kenai <a href="http://kenai.com/projects/divide-and-conquer">Divide and Conquer</a> project; they ain’t pretty. If anyone wants to have a whack at the big dataset, send me a hail and if I think you’re serious I’ll get you an account.
                                </p>
                                <p>
                                    The quest for the Java of Concurrency continues.
                                </p>
                            </div>
                        </blockquote>
                    </div>
                    <p class="bookmark-source">
                        Source: <a href="http://www.tbray.org/ongoing/When/200x/2009/12/01/Clojure-Theses">http://www.tbray.org/ongoing/When/200x/2009/12/01/Clojure-Theses</a>
                    </p>
                </div>
            </article>
            <nav id="post-nav"></nav><script id="discus-javascript">
    var disqus_shortname = 'improbable';

                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                    document.getElementsByTagName('body')[0].appendChild(dsq);
                })();
            </script><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            <div id="disqus_thread"></div>
        </section>
        <footer id="site-footer">
            <p>
                This site is purely my personal work and does not reflect the views of my employer.
            </p>
            <p class="license">
                <a class="icon" rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png"></a> This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.
            </p>
        </footer><script async="" defer src="/static/js/common.js">
</script><script id="google-analytics">
    var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-2097834-1']);
            _gaq.push(['_setDomainName', 'improbable.org']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
    </body>
</html>
